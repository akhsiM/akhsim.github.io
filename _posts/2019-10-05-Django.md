#+TITLE:Django Framework
#+DATE:
#+SETUPFILE: https://akhsim.github.io/read-akhsiM-orgs/theme-readtheorg-akhsiM.setup

<img class="mx-auto w-1/2" src="{{site.baseurl}}/assets/img/orgNotesImages/django-banner.png">

* General

I am learning how to use the Python Django Framework to use a full-on blogging webpage with authentication. There's also gonna be user profile functionalities.

* Setting up virtualenv

First of all we need to install Django with `pip install django`. 

Note: It's recommended to have a separate environment for the project so it's good to use a virtual env. So this is what I did:

```sh
cd `/Documents/Projects
mkdir django-env
cd django-env
virtualenv -p /path/to/python3.7 django-env 
source django-env/bin/activate

pip install django
```

We can verify by checking the version of django by
```sh
python -m django --version
```

* Setting up new project

 ```sh
▶ django-admin startproject --help

usage: django-admin startproject [-h] [--template TEMPLATE]
                                 [--extension EXTENSIONS] [--name FILES]
                                 [--version] [-v {0,1,2,3}]
                                 [--settings SETTINGS]
                                 [--pythonpath PYTHONPATH] [--traceback]
                                 [--no-color] [--force-color]
                                 name [directory]

Creates a Django project directory structure for the given project name in the
current directory or optionally in the given directory. 
```

```sh
django-admin startproject django_project
  ```

** Looking at the Django Project structure

<img class="mx-auto w-1/2" src="{{site.baseurl}}/assets/img/orgNotesImages/django_project-tree.png">

| Module                     | Info                                                                    |
|----------------------------+-------------------------------------------------------------------------|
| manage.py                  | Allows us to run CLI commands                                           |
| django_project/__init__.py | This starts as an empty file                                            |
| django_project/settings.py | This is where we change different settings and config                   |
|                            | Within this file there is a SECRET_KEY and other cool things, including |
|                            | database settings.                                                      |
| urls.py                    | This is where we set up different URL mappings for our user interface   |
|                            | Example: `urlpatterns = [ path('admin/', admin.site.urls)]`               |
| wsgi.py                    | wsgi is how our Python web application and web server communicates      |

* Starting the server

We can do this by running the *manage.py* file:
```sh
python manage.py runserver
```

On default, the web server will start on port 8000, so we can open it via http://localhost:8000/. On default, the `DEBUG=True` means the server will be running on Debug mode i.e any code change we implement will be live.

<img class="mx-auto w-1/2" src="{{site.baseurl}}/assets/img/orgNotesImages/djangostart.png">

*Note*: Upon starting the server for the first time, the following warning can be disregarded for now:
```
You have 17 unapplied migration(s). Your project may not work properly until you apply the migrations for app(s): admin, auth, contenttypes, sessions.
Run 'python manage.py migrate' to apply them.
```

Coming back to this part in the urls.py module:
```python
urlpatterns = [path('admin/', admin.site.urls)]
```

We can navigate to the admin site by going to http://localhost:8000/admin/. However we cannot actually use this yet and there are more configurations that are needed.

Within this urls.py module we can add more route later.

* Adding a Blog Application to Django site

Within our website project which is on Django, we can have several different applications that do their own things on the django projects. One of that can be the blogging app. This way, for example, if you like our blogging app so much we can even install it on other website project that we have.

*What's the difference between a project (`django-admin startproject`) vs an app (`django-admin startapp`)?*

A project refers to the entire suite and all the applications that compose it. A simple project may only have one app.

An app refers to a submodule of the project. An app should be self-sufficient and not intertwined with any other apps in the project. In theory, our app should be plug-and-play and reusable into another project without modification. An app is like a standalone module. An app brings *modularity* to the project. Each app should solve one problem, or "does one thing". 

---

To start an app, we can run
```sh
django-admin startapp blog
```

This creates a directory for our app - 'blog'. This is created by `django-admin startapp`.

```
▶ tree .
.
├── blog
│   ├── admin.py
│   ├── apps.py
│   ├── __init__.py
│   ├── migrations
│   │   └── __init__.py
│   ├── models.py
│   ├── tests.py
│   └── views.py
├── db.sqlite3
├── django_project
│   ├── __init__.py
│   ├── __pycache__
│   │   ├── __init__.cpython-37.pyc
│   │   ├── settings.cpython-37.pyc
│   │   ├── urls.cpython-37.pyc
│   │   └── wsgi.cpython-37.pyc
│   ├── settings.py
│   ├── urls.py
│   └── wsgi.py
└── manage.py
```

As we can see we have a lot already out of the box.

We now create a *urls.py* module in the blog directory. This looks similar to django_project/urls.py:
```python
from django.urls import path
from . import views

urlpatterns = [
    path('', views.home, name ='blog-home'),
]
```

Then we edit *blog/views.py*:
```python
from django.shortcuts import render  ## This was in the out-of-the-box module
from django.http import HttpResponse

def home(request):
    return HttpResponse('<h1>Blog Home </h1>')
```

Then we edit *django_project/urls.py*:
```python
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('blog/', include('blog.urls'))
]
# When we go to /blog/, include urls.py module
```

When we start adding some URL patterns on our project and re-start the server. We no longer get the same homepage with the rocket like before. The project now just tries to match *our specific routes* and not the default routes.

In the DEBUG log we also get:
```sh
[14/Nov/2019 11:04:07] "GET / HTTP/1.1" 404 2034
Not Found: /
```

However if we go to http://localhost:8000/blog now, we can see 'Blog Home' wrapped in <h1> tags.

The orders of URL pattern goes:
1. When we first navigate to the project, it first looks at the project `urls.py` module in the main project folder.
2. If we are going to `/blog/` then it goes OK where do I send people to now... do we have a pattern that matches this navigation? The answers is `blog.urls`. With the `include` function, *it chops off whatever part the URL has matched up to at that point* (`blog/`) and only send the remaining string in the URL to the server.
3. There's nothing after `blog/`, so we go to `blog.urls` i.e `blog.urls.py`.
4. OK with an empty string ,we are in `urls.py`, looking for patterns that match an empty route..
5. OK what do we do now, we found views.home so lets look into `views.py` and run the `home()` function.

We can then add an about page..

First we create the view function:
#+NAME: views.py
```python
from django.shortcuts import render  ## This was in the out-of-the-box module
from django.http import HttpResponse

def home(request):
    return HttpResponse('<h1>Blog Home </h1>')

def about(request):
    return HttpResponse('<h1>Blog About</h1>')
```

Then we add the routing:
#+Name: urls.py
```python
from django.urls import path
from . import views

urlpatterns = [
    path('', views.home, name ='blog-home'),
    path('about/', views.about, name='blog-about')
]
```

.. http://localhost/blog/about is now live!

When we go to this process, what changes is at step 2, because we have `blog/about`, the `include('blog.urls')` will chop off the `blog/` bit, sending the left-over string `about` to the server... Ultimately the call is handled by the `views.about` function.

** Making the blog page the home page

We can do so by leaving the path blank in our root `url.py` module i.e:
```python :exports both :results output :session
path('', include('blog.urls'))
```

This way when we go to http://localhost:8000/ we are routed to `blog/urls.py` then `views.about()`.

** Note about the views Module

The functions that handle the web calls in *views.py* need to take *one argument* at least, but it really doesn't care what we call it. So we could be doing `def home(request):` or we could be doing `def home(shit):`. It doesn't make a real difference.

** Note about Dev mode

Say if we are working on the blog page and it's not really ready for production, we can change the routing of the webpage by going into the main `urls.py` module and update the url patterns to:
```python
urlpatterns = [
	path('admin/', admin.site.urls),
	path('blog_dev/', include('blogs.url'))
]
```

This way we can only access the blog page via `blog_dev`. When anyone tries to go to http://localhost/blog/ they will get a 404.

** The forward slash

We should end the path with a trailing forward slash as a good rule of thumb.
* Working with Templates
** Setting Up

We have worked with setting up the webpage and configure some routing which is cool. However we don't want to keep routing to the same basic HTML page.

In this chapter we'll be using templates to create complex HTML as well as using some variables in our templates.

There is nothing that stops us from typing the entire HTML files in the *views.py* module, e.g:
```python
def home(request):
    return HttpResponse('<h1>Blog Home </h1>')

def about(request):
    return HttpResponse('<h1>Blog About')
```

However it would be extremely ugly.

The best way to go at this is by using *Templates*.

First we need to create a directory *templates/* under our app (i.e *blog/*).

``````
By default, Django automatically looks for the subdirectory *templates/* in all our installed apps.
```

Then we create another subdir *blog/* under *templates/*. After this, it should look like this:

```python
django_project -> blog -> templates -> blog -> templates.html
```

Although it sounds a bit redundant, this is how Django works. We need to create a subdirectory under *templates/* that is has the same name with our installed app.

We then create 2 files *home.html* and *about.html* in *blog/templates/*.

This is *home.html*:
```html
<!DOCTYPE html>
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!-->
<html class="no-js">
<!--<![endif]-->

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Blog Home</title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="">
</head>

<body>
    <!--[if lt IE 7]>
            <p class="browsehappy">You are using an <strong>outdated</strong> browser. Please <a href="#">upgrade your browser</a> to improve your experience.</p>
        <![endif]-->
    <h1>This is the home of Blog!</h1>
    <script src="" async defer></script>
</body>

</html> 
```

Now that we have the templates ready, we have to add the blog application config  to the list of installed apps, so that Django can look for the templates folder.

The app config is *blog/apps.py*:
```python
from django.apps import AppConfig


class BlogConfig(AppConfig):
    name = 'blog'
```

We need to copy the BlogConfig name in the *settings.py* file in *django_project*.

After that, in the settings.py we should have this part:

```python
# Application definition

INSTALLED_APPS = [
    'blog.apps.BlogConfig',
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
]
```

We should always remember to add installed applications config file to list of INSTALLED_APPS in *settings.py* so that our Django web project works correctly and it can look for the right things.

Now we go back to *blog/views.py* and reference to our template:

```python
from django.shortcuts import render  ## This was in the out-of-the-box module
from django.http import HttpResponse

def home(request):
    return render(request, 'blog/home.html')

def about(request):
    return HttpResponse('<h1>Blog About')
```

Now when we go back to http://localhost:8000/blog/ we should be able to see the new Home Page with the HTML structure.

*Note*: The templates folder has be named *templates*. I tried changing this to "Templates" and got error: =TemplateDoesNotExist=.

The *render()* function also takes an optional arguments *context*. We can pass dictionary object to the context argument, with the dictionary object we can then store objects that can be accessed on the HTML page.

*Note*: The *context* argument for render() must be a dict object.

On the HTML page, the syntax for accessing objects is:
- Use single braces for loop
- Use double braces for variable

** Example - render context

Firstly, in *views.py*, we create a list that contains some dictionaries for posts. Within these dictionaries contain some properties for a post like author, title..etc.

Within the *home()* function, we reference this list by creating a dictionary variable, then pass it to our *views.home* function.

We also explicitly passed a title object to the about() function, whereas the home function does not have any 'title' in its context.

Like this:

```python
from django.shortcuts import render  ## This was in the out-of-the-box module
from django.http import HttpResponse

posts = [
    {
        'author': 'Kenny Nguyen',
        'title': 'Blog Post 1',
        'content': 'First Post content',
        'date_posted': 'November 16, 2019'
    },
    {
        'author': 'Mai Nguyen',
        'title': 'Blog Post 2',
        'content': 'Second Post content',
        'date_posted': 'November 17, 2019'
    }
]

def home(request):
    test_context = {
        'test_posts': posts
    }
    return render(request, 'blog/home.html', context=test_context)

def about(request):
    return render(request, 'blog/about.html', context={'title': 'Hello About'})
```

Then, we need to reference the objects in *home.html*:
<img class="mx-auto w-1/2" src="{{site.baseurl}}/assets/img/orgNotesImages/Django.org_20201026_234428_s5pRxl.png">

We also need to change the *about.html* file:
<img class="mx-auto w-1/2" src="{{site.baseurl}}/assets/img/orgNotesImages/Django.org_20201026_234518_lNmOJw.png">

Now, our blog and blog/about pages look like this - Note the difference in title:
<img class="mx-auto w-1/2" src="{{site.baseurl}}/assets/img/orgNotesImages/django-render-context.png">
** Template Inheritance

The above template design is very primitive. There's a lot of *repeated code*, which is bad and violate the *DRY Principles*.

For example, if we want to change the Title page of our blog page, then we'd need to do that for both our home and about template.

*THIS* bit, the `<head>` section,  is repeated in both *home.html* and *about.html*:
<img class="mx-auto w-1/2" src="{{site.baseurl}}/assets/img/orgNotesImages/Django.org_20201026_234548_MxeIHE.png">

The more pages that we have with repeated codes, the worse the problem is.

To solve this problem, we need to accomplish a settings where we have a central place that can be used to store things that are repeatable. Then the pages (e.g about and home) contain only the information that is unique to them.

This is done by using *Template Inheritance*:

*** First we create the patent template - *base.html*:

This base template should contain everything that is repeated in *home.html* and *about.html*.
<img class="mx-auto w-1/2" src="{{site.baseurl}}/assets/img/orgNotesImages/Django.org_20201026_234617_EAxceH.png">

*** Then we edit our child template

The child templates should contain the only things that are unique to them.

- *home.html*:
```html
{% extends "blog/base.html" %}

{% block content %}
    {% for post in test_posts %}
        <h1>{{ post.title }}</h1>
        <p>By {{ post.author }} on {{post.date_posted}}</p>
        <p>{{ post.content}}</p>
    {% endfor %} 
{% endblock content %}

```

- *about.html*:
```html
{% extends "blog/base.html" %}

{% block content %}
        <h2>This is the about of Blog</h2>
{% endblock %}
```

The `extends` block states the inheritance of the parent template *base.html*.

This bit in the parent template is overwritten by the same part in the child template: `{% block content %} {% endblock content %}`. Note that we don't have to specify content after endblock, however this is good practice.

** Bootstrapping

Now, we would like to update our entire website with Bootstrap to make our site look nice and stylish.

With Template inheritance, it's easy to add Bootstrap to our site, since we can just add the required metatag for Bootstrap to our *base.html*. We *do not* need to do the same in our child templates, they stay the same.

The *Starter Template* for Bootstrap is on: https://getbootstrap.com/docs/4.3/getting-started/introduction/

We then add a navigation bar to the base template as well as editting the content block, wrapping it within a main block.

When working on a navbar, we shouldn't hardcode the URLs of our pages into the `<a>` tags because it's very easy and likely that we'd be changing the routing of our page in the future. Instead we should be using the *name* of our page.

Coming back to our *blog/urls.py* module, we can see that we have named our about page "blog-about": `path('about/', views.about, name='blog-about')`. Therefore, on our navbar `<a>` tag, instead of doing `<a href="blog/about">`, we should be using:
```html
<a href="{% url 'blog-about'  %}">About</a>
```

This is why when we name our page, the names should be unique.

We now also need to apply some CSS styling that does come with bootstrap. To store css stylesheets, we need to create a *static* folder within our app i.e *blog/static/*, then we also need to create *blog/static/blog/* which is similar to the structure of our templates directory. Note that the directory has to be named *static* so that Django can read it.

To apply a local css: 
- create a *main.css* file with our styling in *blog/static/blog/*
- in our *base.html*, we need to include that as well. We also need to load the *static/* directory by adding a load block at the top of the file.
  - At the top of *base.html*, we do: `{% load static %}`
  - Then in the body: `<link rel="stylesheet" type="text/css" href="{% static 'blog/main.css' %}">`

After adding a bunch of css, we should restart the webserver to see the styling in effect.

** Review
<img class="mx-auto w-1/2" src="{{site.baseurl}}/assets/img/orgNotesImages/Review-Templates.png">
*** Project directory

	```sh
▶ tree .
.
├── blog
│   ├── admin.py
│   ├── apps.py
│   ├── __init__.py
│   ├── migrations
│   │   ├── __init__.py
│   │   └── __pycache__
│   │       └── __init__.cpython-37.pyc
│   ├── models.py
│   ├── static
│   │   └── blog
│   │       └── main.css
│   ├── templates
│   │   └── blog
│   │       ├── about.html
│   │       ├── base.html
│   │       └── home.html
│   ├── tests.py
│   ├── urls.py
│   └── views.py
├── db.sqlite3
├── django_project
│   ├── __init__.py
│   ├── settings.py
│   ├── urls.py
│   └── wsgi.py
└── manage.py
	```

*** HTML Templates

**** base.html 
	 ```html
{% load static %}
<!DOCTYPE html>
<html lang="en">

    <head>

        <head>
            <!-- Required meta tags -->
            <meta charset="utf-8">
            <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

            <!-- Bootstrap CSS -->
            <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css"
                integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T"
                crossorigin="anonymous">
            
            <!-- Local CSS  -->
            <link rel="stylesheet" type="text/css" href="{% static 'blog/main.css' %}">

            {% if title %}
                <title>Django Blog - {{ title }}</title>
            {% else %}
                <title>Django Blog</title>
            {% endif %}
        </head>
    </head>

    <body>
        <header class="site-header">
            <nav class="navbar navbar-expand-md navbar-dark bg-steel fixed-top">
                <div class="container">
                    <a class="navbar-brand mr-5" href="{% url 'blog-home' %}">Django Blog </a>
                    <button class="navbar-toggler" type="button" data-toggle="collapse">
                        <span class="navbar-toggler-icon"></span>
                    </button>
                    <div class="collapse navbar-collapse" id="navbarToggle">
                        <div class="navbar-nav mr-auto">
                            <a class="nav-item nav-link" href="{% url 'blog-home' %}">Home</a>
                            <a class="nav-item nav-link" href="{% url 'blog-about' %}">About</a>
                        </div>
                        <!-- Nav Bar Right Side -->
                        <div class="navbar-nav">
                            <a class="nav-item nav-link" href="#">Login</a>
                            <a class="nav-item nav-link" href="#">Register</a>
                        </div>
                    </div>
                </div>
            </nav>
        </header>

        <main role="main" class="container">
            <div class="row">
                <div class="col-md-8">
                    {% block content %}{% endblock %}
                </div>
                <div class="col-md-4">
                    <div class="content-section">
                        <h3>Sidebar</h3>
                        <p class='text-muted'>Any information</p>
                        <ul class="list-group">
                            <li class="list-group-item list-group-item-light">Latest Post</li>
                            <li class="list-group-item list-group-item-light">Announcement</li>
                            <li class="list-group-item list-group-item-light">Calendars</li>
                            <li class="list-group-item list-group-item-light">etc</li>
                        </ul>
                    </div>
                </div>
            </div>
        </main>
        <!-- Optional JavaScript -->
        <!-- jQuery first, then Popper.js, then Bootstrap JS -->
        <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js" integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1" crossorigin="anonymous"></script>
        <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>
    </body>

</html>
	 ```

**** about.html
	 ```html
{% extends "blog/base.html" %}

{% block content %}
        <h2>This is the about of Blog</h2>
{% endblock %}	 
	 ```

**** home.html
	 ```html
{% extends "blog/base.html" %}

{% block content %}
    {% for post in test_posts %}
        <!-- <h1>{{ post.title }}</h1>
        <p>By {{ post.author }} on {{post.date_posted}}</p>
        <p>{{ post.content}}</p> -->

        <article class="media content-section">
            <div class="media-body">
                <div class="article-metadata">
                    <a class="mr-2" href="#"> {{ post.author }}</a>
                    <small class="text-muted">{{ post.date_posted }}</small>
                </div>
                <h2> <a class="article-title" href="#">{{ post.title }}</a></h2>
                <p class="article-content">{{ post.content }}</p>
            </div>
        </article>
    {% endfor %} 
{% endblock %}
	 ```

*** static/main.css
	```css
body {
    background: #fafafa;
    color: #333333;
    margin-top: 5rem;
}

h1, h2, h3, h4, h5, h6 {
    color: #444444;
}

ul {
    margin: 0;
}

.bg-steel {
    background-color: #5f788a;
}

.site-header .navbar-nav .nav-link {
    color: #cbd5db;
}

.content-section{
    background:#ffffff;
    padding:10px 20px;
    border: 1px solid #dddddd;
    border-radius:3px;
    margin-bottom:20px;
}

.article-title {
    color: #444444;
}

a.article-title:hover{
    color:#428bca;
    text-decoration: none;
}

.article-content {
    white-space:pre-line
}

.article-img{
    height: 65px;
    width: 65px;
    margin-right: 16px;
}

.article-metadata {
    padding-bottom: 1px;
    margin-bottom: 10px;
    border-bottom: 1px solid #e3e3e3;
}

.article-metadata a:hover{
    color: #333;
    text-decoration: none;
}
.article-svg {
    width: 25px;
    height: 25px;
    vertical-align: middle;
  }
  
.account-img {
    height: 125px;
    width: 125px;
    margin-right: 20px;
    margin-bottom: 16px;
}

.account-heading {
    font-size: 2.5rem;
}
	```
* First look at the Admin Page

The Admin Page of our Django site can be used as a GUI interface to see the data on our site as well as to update that data. 

The Admin Page URL is http://localhost:8000/admin.

There is no default admin credentials so we have to set that up ourselves. That can be done using *CLI*:

```sh
python manage.py createsuperuser
```

If we has just run this right off the bat we'd have a bunch of error. The last one gives us a hint on what the issue is:

```
django.db.utils.OperationalError: no such table: auth_user 
```

The problem here is that we haven't got a database to store our persistent object yet.

We first need to set up our database. In Django, this concept is called [[https://docs.djangoproject.com/en/2.2/topics/migrations/][Migrations]]. Migrations are Django's way of propagating the changes we make to our models (adding a field, deleting a model..etc.) into our database schema. They are designed to be mostly automatic, however we'll need to know when to make migrations and the common problems that we run into.



Common commands are:
- `migrate`: responsible for applying un unapplying migrations
- `makemigrations`: creating new migrations based on the changes we have made to our models
- `sqlmigrate`: displays SQL statements for a migration
- `showmigrations`: lists a project's migrations and their status.

For example, we can run:
```sh
python manage.py makemigrations
```

```
No changes detected
```

This indicates that Django detected no change that has been applied to our model.

However we need to run this, which will be successful:
```sh
python manage.py migrate
```

and then now we can create our admin user by:
```sh
python manage.py createsuperuser
```

This will create a file called *db.sqlite3* in our django_project folder.
```sh
tree -L 1 .
```

```
.
├── blog
├── db.sqlite3
├── django_project
└── manage.py
```

Now we can run our server again. Then we can access out Admin site. This Admin Site makes it easier to do our a lot of our configuration using GUI, without having to code everything from scratch.

<img class="mx-auto w-1/2" src="{{site.baseurl}}/assets/img/orgNotesImages/Django-Admin.png">

The Django Admin site is one of the most powerful parts of Django. It reads metadata from our modesl to provide a quick, model-centric interface where contents can be managed by trusted and authenticated users. However, the admin site is not intended to for building our entire site front-end around.

The admin is enable in the default project template used by `django-admin startproject`. If we are not using the default project, we need to add `django.contrib.admin` and its dependencies to our *INSTALLED_APPS* settings.

Back to our admin site, if we go to *Users* we can see the super user we just created. *Raw Passwords are not stored* on this and there is no way to see a user's password. The password string is hashed to death. This is an awesome level of security that is just available to us on default.

If we create another user, the default level of Permissions only has *Active*, not Staff Status or Superuser Status. Staff Status allows someone to log into the Admin site. For a user with staff status, on default they don't have permission to do anything.
* Database and Migrations

Here we are going to start working with real database tables  and not having to rely on dummy data. With real database we can then start doing real Posts.

To work with database, Django has a built-in feature called *Object Relational Mapper (ORM)*. ORM allows us to easily use and access our database using object-oriented methodology. We can also use *different databases* without changing our code. Another great thing about ORM is that we can represent our database structure as *classes*. These classes are called *model*.

For this project we are going to be using a sqllite db for dev and postgres for production.

Within our blog app directory, there is a file *models.py*. Within this file, we can save things to our database. The first thing we need to do is to create a *Post* class/ model in this file that inherits from the Model class in Django library models.

Keep in mind that the user class has been created in the previous chapter.

** First, we create the Post class 

 *blog/models.py*:
 ```python
 from django.db import models
 from django.utils import timezone
 from django.contrib.auth.models import User

 class Post(models.Model):
     title = models.CharField(max_length=100)
     content = models.TextField() # Unrestricted text
     date_posted = models.DateTimeField(default=timezone.now)
     # (For the above we can also do DateTimeField(auto_now_add = True) 
     author = models.ForeignKey(User, on_delete=models.CASCADE)
     # This specifies a many-to-one relationship
     # Also, on delete of user, also delete the post(s) as well
 ```

** Secondly, we apply the Post class by making the actual migration

 Then we make migrations to apply the classes we just made:
 ```sh
 python manage.py makemigrations
 ```

 ```
 Migrations for 'blog':
   blog/migrations/0001_initial.py
     - Create model Post
 ```

 As we can see, the *0001_initial.py* file is created in the *migrations* dir. We shouldn't touch this stuff, but information can be gather by looking at the file. We can obviously see the table structure in it. There is a lot more information in *models.py*.

 Note that the *0001* is the migration number. The *migrations* dir is also located under *blog* which is the name of the app.

 ```python
 # Generated by Django 2.2.7 on 2019-11-18 11:24

 from django.conf import settings
 from django.db import migrations, models
 import django.db.models.deletion
 import django.utils.timezone


 class Migration(migrations.Migration):

     initial = True

     dependencies = [
         migrations.swappable_dependency(settings.AUTH_USER_MODEL),
     ]

     operations = [
         migrations.CreateModel(
             name='Post',
             fields=[
                 ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                 ('title', models.CharField(max_length=100)),
                 ('content', models.TextField()),
                 ('date_posted', models.DateTimeField(default=django.utils.timezone.now)),
                 ('author', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL)),
             ],
         ),
     ]
 ```

 These are the information that will be run when we do *python manage.py migrate*. 

*** Sneak Peek of the SQL

  Now we can run the following which displays the SQL code that will be run:

  ```sh
  python manage.py sqlmigrate blog 0001
  ```

  ```
  BEGIN;
  --
  -- Create model Post
  --
  CREATE TABLE "blog_post" ("id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, "title" varchar(100) NOT NULL, "content" text NOT NULL, "date_posted" datetime NOT NULL, "author_id" integer NOT NULL REFERENCES "auth_user" ("id") DEFERRABLE INITIALLY DEFERRED);
  CREATE INDEX "blog_post_author_id_dd7a8485" ON "blog_post" ("author_id");
  COMMIT;
  ```

  Note that even though we didn't specify the *id* field, Django automatically creates it and use it as the autoincremented PK.

  This is why ORM is very convenient.

** Third, we create the table

 Note that the *sqlmigrate* command doesn't actually run the migrate. It only displays the SQL command for a migration.

 We now need to run:
 ```sh
 python manage.py migrate
 ```
 ```
 Operations to perform:
   Apply all migrations: admin, auth, blog, contenttypes, sessions
 Running migrations:
   Applying blog.0001_initial... OK
 ```

 With Django Migrations, changes can be made in our database even after we have added things onto it.

** Playing with our Database object in Django Shell

We can look into out database by:
```sh
python manage.py shell
```

<img class="mx-auto w-1/2" src="{{site.baseurl}}/assets/img/orgNotesImages/django-shell1.png">


<img class="mx-auto w-1/2" src="{{site.baseurl}}/assets/img/orgNotesImages/django-shell2.png">


We can create a post:

<img class="mx-auto w-1/2" src="{{site.baseurl}}/assets/img/orgNotesImages/django-shell3.png">

Why the hell is Posts.objects.all() still returns an empty list? It's because we have *not* saved our Post.

<img class="mx-auto w-1/2" src="{{site.baseurl}}/assets/img/orgNotesImages/django-shell4.png">


Now, we are going to go *back* to our *blog/models.py* file and add a new method to our class - a `__str__()` method. This magic/ Dunder method is what's being called when we want to run `Post.objects.*`. Right now our Post class is missing a `__str__()`, so it just says "Post object (1)".

This is our new *blog/models.py* file:
```python
from django.db import models
from django.utils import timezone
from django.contrib.auth.models import User

class Post(models.Model):
    title = models.CharField(max_length=100)
    content = models.TextField() # Unrestricted text
    date_posted = models.DateTimeField(default=timezone.now)
    # (For the above we can also do DateTimeField(auto_now_add = True) 
    author = models.ForeignKey(User, on_delete=models.CASCADE)
    # This specifies a many-to-one relationship
    # Also, on delete of user, also delete the post(s) as well
    
    def __str__(self):
        return self.title
```

We now need to exit the shell and open it back.

<img class="mx-auto w-1/2" src="{{site.baseurl}}/assets/img/orgNotesImages/django-shell5.png">

Voila! With the new `__str__()` method, we can now see the Post title.

Another way to create a post is by using *author_id* instead of author object:
<img class="mx-auto w-1/2" src="{{site.baseurl}}/assets/img/orgNotesImages/django-shell6.png">

We can look at the Post object:
<img class="mx-auto w-1/2" src="{{site.baseurl}}/assets/img/orgNotesImages/django-shell7.png">

We can find out all the psots by a specific user:
<img class="mx-auto w-1/2" src="{{site.baseurl}}/assets/img/orgNotesImages/django-shell8.png">

This is a special query set - *[modelname]_set*

We can also use this to create a post:
<img class="mx-auto w-1/2" src="{{site.baseurl}}/assets/img/orgNotesImages/django-shell9.png">
Note: This time we do not have to `save()`.


** Back to *blog/views.py*

Previously we have some crappy dummy data for our Post. Now that we have a "real" post object, we can refer to that one instead.

```python
from django.shortcuts import render
from django.http import HttpResponse
from .models import Post


def home(request):
    context = {
        'posts': Post.objects.all()
    }
    return render(request, 'blog/home.html', context=context)

def about(request):
    return render(request, 'blog/about.html', context={'title': 'Hello About'})
```

<img class="mx-auto w-1/2" src="{{site.baseurl}}/assets/img/orgNotesImages/django-site-blog.png">

We also have to edit the *blog/home.html* file for the format of our date_posted on line 13:
```python
<small class="text-muted">{{ post.date_posted|date:"Y M, d" }}</small>
```

<img class="mx-auto w-1/2" src="{{site.baseurl}}/assets/img/orgNotesImages/django-site-blog2.png">

*** Back to Django Admin Site

Our Django Admin site still only has the *Groups* and *Users* model.

We now need to register the Post model to our admin site. We can do this by looking into *blog/admin.py*:
```python
from django.contrib import admin
from .models import Post

admin.site.register(Post)
```

voila!

<img class="mx-auto w-1/2" src="{{site.baseurl}}/assets/img/orgNotesImages/django-adminsite.png">

We can now go into the Blog model administration page and create new stuff.

* User Registration

We need to create a User app by navigating to our project directory then:

```python
python manage.py startapp users
```

Now we can see the users app along with our blog app.

We need to create a User Registration Page for front-end users to register the page. But first we should add the users app to the project's *settings.py* file, in the *INSTALLED_APPS* list. We do this by adding `'users.apps.UsersConfig'` to the list.

** First we start with creating the view function

We create a new function in *users/views.py*. 

It's possible to create a User Registration form from scratch. However Django also has a library for us and we can just import and use it. We will need to insert the form object as *context* for the `render()` method.

```python
from django.shortcuts import render
from django.contrib.auth.forms import UserCreationForm

def register(request):
    form = UserCreationForm() # create a new UserCreationFrom instance
    return render(request, 'users/register.html', {'form': form})
```

Then we move on to create the *register.html* file.

** Secondly we create the template *register.html*

This file should be located in *users/templates/users*.

Note that because we have passed the *UserCreationForm* instance as context for the render, and named it *'form*', we can now just call the object by `{{ form }}`.

```html
{% extends "blog/base.html" %}
{% block content %}
    <div class="content-section">
        <form method="POST">
            <!-- The csrf token adds an extra layer of security. It's a must-have for Django. -->
            {% csrf_token %}
            <fieldset class="form-group">
                <legend class="border-bottm mb-4">Create an Account</legend>
                {{ form }}
            </fieldset>
            <div class="form-group">
                <button class="btn btn-outline-dark" type="submit">Sign Up</button>
            </div>
        </form>
        <div class="border-top pt-3">
            <small class="text-muted">
                Already have an Account? <a class="ml-2" href="#">Log in here.</a>
            </small>
        </div>
    </div>
{% endblock content%}
```

*** About the HTML `<form> method` attribute

The HTML `<form>` element has an atribute `method`. This attribute is used to specify the HTTP method used to send data when we submit the form.

There are two kinds of HTTP methods, which are GET and POST.


** Then we configure the routing in *register/urls.py*

Instead of having a separate *urls.py* module for the app, i.e what we did with blogs, because the user registers app is a relatively simple one, we can just configure the routing in the project *urls.py* module.

We need to import the views module by `from users import views as user_views` first though.

So the module looks like this:
```python
from django.contrib import admin
from django.urls import path, include
from users import views as user_views

urlpatterns = [
    path('admin/', admin.site.urls),
    path('', include('blog.urls')),
    path('register/', user_views.views, name='register')
]
```

** Our Register Page is ready!

Now if we go to http://localhost:8000/register, we see:

<img class="mx-auto w-1/2" src="{{site.baseurl}}/assets/img/orgNotesImages/django-register.png">

Although we have got out Register page, it doesn't look pretty. However this can definitely be improved easily.

For example, in the *register.html* file, if we change the line from `{{ form }}` to `{{ form.as_p }}` then we get the Password on the second line.

** Handling the POST request in *views.py*

The form doesn't do anything yet, i.e if we input information and hit the Sign Up button, we just get redirected to the same page.

If we go back to our *register.views.py, right now the module only handles GET request and returns a rendered response.

For out site to know how to handle POST request, we need to specify that in the *views.py* module. We need to do a check to see if the request we get is a POST, then we'd properly handle it, or else, just return the page.

   ```python
from django.shortcuts import render, redirect
from django.contrib.auth.forms import UserCreationForm
from django.contrib import messages


def register(request):
    if request.method == 'POST':
        form = UserCreationForm(request.POST)
        if form.is_valid():
            username = form.cleaned_data.get('username')
            messages.success(request, f'Account created for {username}!')      
            return redirect('blog-home')     
    else:
        form = UserCreationForm()
    return render(request, 'users/register.html', {'form': form})

   ```

*Note*:

- The messages library contains method for different type of messages.
- In this module now, we can see that the `request` argument is not just any object. It's actually a *HttpRequest* object. Django uses request and response objects to pass state through the system. When a page is requested, Django creates a *HttpRequest* object that contains *metadata* about the request. *Then Django loads the appropriate view, passing the HttpRequest as the *first argument to the view function*. For more information about the HttpResponse object, see [[https://docs.djangoproject.com/en/2.2/ref/request-response/][here]].
- The `form` variable is a dicitonary-like object containing all the given HTTP POST parameters.

``````
*HttpRequest.POST*

    A dictionary-like object containing all given HTTP POST parameters, providing that the request contains form data. See the QueryDict documentation below. If you need to access raw or non-form data posted in the request, access this through the HttpRequest.body attribute instead.

    It’s possible that a request can come in via POST with an empty POST dictionary – if, say, a form is requested via the POST HTTP method but does not include form data. Therefore, you shouldn’t use if request.POST to check for use of the POST method; instead, use if request.method == "POST" (see HttpRequest.method).

    POST does not include file-upload information. See FILES.

```

** Handling the message

In the *views.py* module, we return a *messages.success()* method call as well as redirect the user back to *blog-home*. This is the unique identifier of our blog home page that has been set in *blog/urls.py.*

What this means is, when the *register/views.py* module receives a POST request, it checks whether the request is valid, then send the user back to the blog home page.

We also need to configure our html page to show the message object on the screen.

For this we can put that into the *base.html* template, right above the content block. See snippet below:
```html
                <div class="col-md-8">
                    {% if messages %}
                        {% for message in messages %}
                            <div class="alert alert-{{ message.tags }}">{{ message }}</div>
                        {% endfor %}
                    {% endif %}
                    {% block content %}{% endblock content %}
                </div>

```

So now, when we finish the user registration form and have input the right data (same passwords), we are brought back to home blog-home page with a success message.

<img class="mx-auto w-1/2" src="{{site.baseurl}}/assets/img/orgNotesImages/django-register-success.png">

The nice thing about messages is that it's not a persistent object. If we refresh the page the message disappear.

*** More about the messages framework

This framework is to display a one-time notification message, a.k.a *flash message* to the user after processing a form or some other types of user input.

The messages framework allows us to temporarily store message in one request and retrieve them for display in a subsequent request (usually the next one). Every message has a tag that indicates the specific *level* that determines its priority e.g info, warning, error..etc.

Messages are implemented through a middleware class and corresponding context processor.

The *settings.py* module of our django project already contains all the settings required to enable the message functionality.

```python
INSTALLED_APPS = [
    'django.contrib.messages'
]

MIDDLEWARE = [
    'django.contrib.messages.middleware.MessageMiddleware'
]
```


*Note* that when we failed the Password verification, we are returned to *register.html* with the Username already filled up. This is because the form variable still retains the information from the POST request, i.e the values that we have submitted.


** Set Up 'Save the User'

We need to set this up so that the user account is actually created if the form is valid.

Within django, this is very easy. All we need to do is by adding the `form.save()` statement. This statement should be placed within the `if form.is_valid()` block.

After this, when we successfully create the user account, we can then find it in the admin page.

```python
from django.shortcuts import render, redirect
from django.contrib.auth.forms import UserCreationForm
from django.contrib import messages


def register(request):
    if request.method == 'POST':
        form = UserCreationForm(request.POST)
        if form.is_valid():
            form.save()
            username = form.cleaned_data.get('username')
            messages.success(request, f'Account created for {username}!')      
            return redirect('blog-home')     
    else:
        form = UserCreationForm()
    return render(request, 'users/register.html', {'form': form})
```

*** More about the save() method
	
Form is basically an object of a subclass of the *ModelForm* class. Every *ModelForm* has a *save()* method.

This method creates and saves a database object from the data bound to the form. A subclass of ModelForm can accept an existing model instance as the keyword argument *instance*. If this is supplied, *save()* will update that instance. If it's not supplied, *save()* will create a new instance of the specified method.

More here: https://docs.djangoproject.com/en/2.2/topics/forms/modelforms/#the-save-method

** Set Up 'User Email Address' field

Now we look at back at *register.html* file. We can see that we are not printing individual fields within the form object. All we are doing is: `form.as_p` and it's printing out all the fields for us.

In order to print a new field, we need to add it to the actual model itself.

The UserCreationForm is one we have imported from the django library. To add a new field to this, we need to create a new class that inherits from UserCreationForm.

We need to create this new form in a seperate module, we call this *forms.py*. This can reside within our *users* directory.

*users/forms.py*
```python
from django import forms
from django.contrib.auth.models import User 
from django.contrib.auth.forms import UserCreationForm

class UserRegisterForm(UserCreationForm):
    email = forms.EmailField() ## required=True is default
    
    class Meta:
        model = User ## Use the default User model. When save, save to User model
        fields = ['username', 'email', 'password1', 'password2'] ## These are going to be shown on our form, in THIS order.
```

Then we rewrote our *views.py* so that *UserRegisterForm* is used instead of *UserCreationForm*:
```python
from django.shortcuts import render, redirect
from django.contrib import messages
from .forms import UserRegisterForm

def register(request):
    if request.method == 'POST':
        form = UserRegisterForm(request.POST)
        if form.is_valid():
            form.save()
            username = form.cleaned_data.get('username')
            messages.success(request, f'Account created for {username}!')      
            return redirect('blog-home')     
    else:
        form = UserRegisterForm()
    return render(request, 'users/register.html', {'form': form})
```

Now our *register* page should look different:

<img class="mx-auto w-1/2" src="{{site.baseurl}}/assets/img/orgNotesImages/django-register-with-email.png">

*** Class Meta

The model metadata is *"anything that's not a field"* such as ordering options, database table name..etc.. Addition of class Meta to a class is completely optional.

What we did above is essentially providing *metadata* to the *ModelForm* class. These metadata are called *attributes*.

In the above example, we have specified the model that our form will be interacting with to be User and the fields that displayed are username, email, password and password verification. When we do a form.save(), the User model is the one impacted.

The *Class Meta* gives us a *Nested Namespace* for configuration purpose and keep the configuration in one place.



** Restyling the form

We need to add some cool stuff to the styling of our form. There are ways that we can do this within the *forms.py* module however this is a good idea. It would better if we can do all styling in our *template*.

For this, we use the *Crispy Forms* library. It allows us to style our form in Bootstrap fashion.

First we need to install that within our virtual environment:

```sh
source django-env/bin/activate
```

After running this, if we do a `which python` it should points to the python program within our virtual env, not the actual host machine.

Then we do

```sh
pip install django-crispy-forms
```

After this library is installed, we need to tell Django that this is an installed app. We do this by opening the *settings.py* module and add `'crispy_forms'` to the list of `INSTALLED_APPS`.

We also need to add one more line into the *settings.py* module to tell Crispy Forms to use Bootstrap 4 instead of Bootstrap 2:
```python
CRISPY_TEMPLATE_PACK = 'bootstrap4'
```

Now crispy form is up, we just need to load it into our template. We do this by adding `{% load crispy_forms_tags %}` into our register template file *register.html*.

Then, instead of doing `form.as_p`, we simply change it to `form | crispy`. Note that the use of the vertical slash is similar to how we used it previously in *blog/home.html* to format out date_posted.

We can definitely add more styling to our form, however we will stop with using crispy out-of-the-box.

Our form looks nicer now:

<img class="mx-auto w-1/2" src="{{site.baseurl}}/assets/img/orgNotesImages/django-crispy.png">

If we view the source, there's a lot of styling that is added with just `| cripsy`:

```html
<div id="div_id_username" class="form-group"> <label for="id_username" class=" requiredField">
                Username<span class="asteriskField">*</span> </label> <div class=""> <input type="text" name="username" maxlength="150" autofocus class="textinput textInput form-control" required id="id_username"> <small id="hint_id_username" class="form-text text-muted">Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.</small> </div> </div> <div id="div_id_email" class="form-group"> <label for="id_email" class=" requiredField">
                Email<span class="asteriskField">*</span> </label> <div class=""> <input type="email" name="email" class="emailinput form-control" required id="id_email"> </div> </div> <div id="div_id_password1" class="form-group"> <label for="id_password1" class=" requiredField">
                Password<span class="asteriskField">*</span> </label> <div class=""> <input type="password" name="password1" class="textinput textInput form-control" required id="id_password1"> <small id="hint_id_password1" class="form-text text-muted"><ul><li>Your password can&#39;t be too similar to your other personal information.</li><li>Your password must contain at least 8 characters.</li><li>Your password can&#39;t be a commonly used password.</li><li>Your password can&#39;t be entirely numeric.</li></ul></small> </div> </div> <div id="div_id_password2" class="form-group"> <label for="id_password2" class=" requiredField">
                Password confirmation<span class="asteriskField">*</span> </label> <div class=""> <input type="password" name="password2" class="textinput textInput form-control" required id="id_password2"> <small id="hint_id_password2" class="form-text text-muted">Enter the same password as before, for verification.</small> </div> </div>
```

The form will also return better error message. The fields that have problems are also high-lighted in red.

*** *settings.py*
	```python
	"""
Django settings for django_project project.

Generated by 'django-admin startproject' using Django 2.2.7.

For more information on this file, see
https://docs.djangoproject.com/en/2.2/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/2.2/ref/settings/
"""

import os

# Build paths inside the project like this: os.path.join(BASE_DIR, ...)
BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/2.2/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = 'nujy___q1ag!93y&yner^)_m(avs*z4)fgwm8lrz$uffu-tf85'

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

ALLOWED_HOSTS = []


# Application definition

INSTALLED_APPS = [
    'crispy_forms',
    'users.apps.UsersConfig',
    'blog.apps.BlogConfig',
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
]

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'django_project.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'django_project.wsgi.application'


# Database
# https://docs.djangoproject.com/en/2.2/ref/settings/#databases

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),
    }
}


# Password validation
# https://docs.djangoproject.com/en/2.2/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]


# Internationalization
# https://docs.djangoproject.com/en/2.2/topics/i18n/

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'UTC'

USE_I18N = True

USE_L10N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/2.2/howto/static-files/

STATIC_URL = '/static/'

CRISPY_TEMPLATE_PACK = 'bootstrap4'
	```

*** *register.html*

	```html
{% extends "blog/base.html" %}
{% load crispy_forms_tags %}

{% block content %}
    <div class="content-section">
        <form method="POST">
            <!-- The csrf token adds an extra layer of security. It's a must-have for Django. -->
            {% csrf_token %}
            <fieldset class="form-group">
                <legend class="border-bottm mb-4">Create an Account</legend>
                {{ form | crispy  }}
            </fieldset>
            <div class="form-group">
                <button class="btn btn-outline-dark" type="submit">Sign Up</button>
            </div>
        </form>
        <div class="border-top pt-3">
            <small class="text-muted">
                Already have an Account? <a class="ml-2" href="#">Log in here.</a>
            </small>
        </div>
    </div>
{% endblock content%}
	```

* User Authentication system

This needs to be done so that users can log in/ log out. We also need to create some level of restrictions.

By default, the admin module can only be accessible by the admins. Newly created users cannot access this page and needs a dedicated login page.

Luckily, Django has this covered. There is a default login view in the Django Library.

** Setup the view function

This LoginView (and also LogoutView) is called class-based view. We can set these up within our project *urls.py* i.e *django_project/urls.py*:
```python
from django.contrib import admin
from django.urls import path, include
from users import views as user_views
from django.contrib.auth import views as auth_views

urlpatterns = [
    path('admin/', admin.site.urls),
    path('', include('blog.urls')),
    path('register/', user_views.register, name='register'),
    path('login/', auth_views.LoginView.as_view(), name='login'),
    path('logout/', auth_views.LogoutView.as_view(), name='logout')
```

These class-based views will handle the application logic for us in the back-end. However it is not going to handle the template. This is a good thing because we want to use our own template, that matches the look and feel of our own webpage.

** Set up the template

If we just set up the view, save the module and browse to http://localhost:8000/login/, we'd get an exception: `TemplateDoesNotExist at /login/`. This error means that Django is trying to look for a template but couldn't find it. Head of the error is copied below:
```
TemplateDoesNotExist at /login/

registration/login.html

Request Method: 	GET
Request URL: 	http://localhost:8000/login/
Django Version: 	2.2.7
Exception Type: 	TemplateDoesNotExist
Exception Value: 	

registration/login.html
```

We can see that the Django LoginView is trying to look for the template in the *registration/* directory by default. We could just create a registration directory. However we can configure this as well, then tell Django to look for the *login.html* in another location. This can be done by passing an argument in the *as_view()* method.

So now, our *django_project/urls.py* should look like this

```python
from django.contrib import admin
from django.urls import path, include
from users import views as user_views
from django.contrib.auth import views as auth_views

urlpatterns = [
    path('admin/', admin.site.urls),
    path('', include('blog.urls')),
    path('register/', user_views.register, name='register'),
    path('login/', auth_views.LoginView.as_view(template_name='users/login.html'), name='login'),
    path('logout/', auth_views.LogoutView.as_view(template_name='users/logout.html'), name='logout')
]
```

*Important Note*: Even though the template_name has been specified as *users/login.html*, what Django will look for is "the login.html file in the template of users", which essentially means: *users/templates/users/login.html*. Therefore we need to create our two templates in *users/templates/users/*.

We can now write our *login.html* template. We just need to copy from *register.html* and change a few things.
```html
{% extends "blog/base.html" %}
{% load crispy_forms_tags %}

{% block content %}
    <div class="content-section">
        <form method="POST">
            <!-- The csrf token adds an extra layer of security. It's a must-have for Django. -->
            {% csrf_token %}
            <fieldset class="form-group">
                <legend class="border-bottm mb-4">Log in</legend>
                {{ form | crispy  }}
            </fieldset>
            <div class="form-group">
                <button class="btn btn-outline-dark" type="submit">Login</button>
            </div>
        </form>
        <div class="border-top pt-3">
            <small class="text-muted">
                Need an account? <a class="ml-2" href="{% url 'register' %}">Register here.</a>
            </small>
        </div>
    </div>
{% endblock content%}
```

Our Login page should work now and it has some functionalities. If we log in with bad username/ password, Django will throw an error.

** Handling the Login Redirect

However, at this stage, if we log in with the correct credentials, we'd receive a 404 Respone. This is because our project hasn't been set-up for login redirect.

``````
Page not found (404)
Request Method: 	GET
Request URL: 	http://localhost:8000/accounts/profile/

Using the URLconf defined in django_project.urls, Django tried these URL patterns, in this order:

    admin/
    [name='blog-home']
    about/ [name='blog-about']
    register/ [name='register']
    login/ [name='login']
    logout/ [name='logout']

The current path, accounts/profile/, didn't match any of these.
```

As we can see, Django is trying to look for the view for the url *accounts/profile/*. This route is the default setup. We can definitely change the routing for this so that instead of routing the user to their user account page, we just direct them to our blog.

To change the login redirect page, we need to go to our project *settings.py* and add this to the file:

```python
LOGIN_REDIRECT_URL = 'blog-home'
```

With this in place. if we go back to out login page and submit a valid set of credentials, we'd be redirected back to our blog home page. Although we haven't set up any feed back that tells the user something like /"OK you've logged in"/, what we can do is navigate to our */admin/* page and find that we are already authenticated.

If we log in, with an account without admin access, we'd receive an error:
<img class="mx-auto w-1/2" src="{{site.baseurl}}/assets/img/orgNotesImages/django-admin-err.png">

Now that we have a login page, for our register view, after someone has created an account, we don't need to redirect them back to *blog-home*. Rather, we direct them to our login page and ask them to log in i.e

```python
            messages.success(request, f'Account created for {username}, log in now!')
            return redirect('login')       
```

** Logout Template

Unlike the LoginView which needs a template, the Logoutview still works *without* the argument `template_name='user/logout.html'`.

However we shouldn't be using the default template, because it links users to log in back *via the admin module* which is not always wanted.

To create a tempate for logout, we can just copy the login.html one and change things. Since the logout page will not have a form, things will be simpler.

*logout.html*
```html
{% extends "blog/base.html" %}

{% block content %}
    <h2>You have been logged out.</h2>
            <div class="border-top pt-3">
                <small class="text-muted">
                    Want to log back in? <a class="ml-1" href="{% url 'login' %}">Log in here.</a>
                </small>
            </div>
{% endblock content%}
```

<img class="mx-auto w-1/2" src="{{site.baseurl}}/assets/img/orgNotesImages/django-logout.png">




** Touching up

Now that we have login and logout pages, we should change out template sidebar to indicate whether someone has logged in, or out.

If someone hasn't logged in, they should see the login page. If someone has logged in, they should then see the log out page. This condition can be placed in our *base.html* template. Currently this is in *root/blog/templates/blog/base.html*.

Django makes this easy for us by providing a conditional user variable that we can use.

So now, what we do is updating our *base.html*, specifically the bit within the `<div class="navbar-bar">` element that currently contains the Login and Resister URL:

*FROM*
```html
<a class="nav-item nav-link" href="#">Login</a>
<a class="nav-item nav-link" href="#">Register</a>
```

.. *TO*:
```html
{% if user.is_authenticated %}
    <a class="nav-item nav-link" href="{% url 'logout' %}">Logout</a>
{% else %}
    <a class="nav-item nav-link" href="{% url 'login' %}">Login</a>
    <a class="nav-item nav-link" href="{% url 'register' %}">Register</a>
{% endif %}
```

Now if we try logging in, we could then only see the logout page.


** Enabling restriction

We now need to put on some restriction on the page. This is typically set up for the user profile page. For example if someone goes into the user profile page without having logged in, they need to be asked to log in first.

We can do this by adding the following function into *users/views.py*:
```python
def profile(request):
    return render(request, 'users/profile.html')
```

Then we need to create the template within *users/templates/users/*.

*profile.html*
```html
{% extends "blog/base.html" %}
{% load crispy_forms_tags %}

{% block content %}
    <h1>{{ user.username }}</h1>
{% endblock content%}
```

The user attribute is one that comes with Django and we don't need to configure it.

At this stage, for the profile page, we have the view function for it, we have the template for it. We now need to configure the routing in our *django_project/urls.py* module:
```python
urlpatterns = [
    path('admin/', admin.site.urls),
    path('', include('blog.urls')),
    path('register/', user_views.register, name='register'),
    path('login/', auth_views.LoginView.as_view(template_name='users/login.html'), name='login'),
    path('logout/', auth_views.LogoutView.as_view(template_name='users/logout.html'), name='logout'),
    path('profile/', user_views.profile, name='profile')
]
```

We should also add the profile link to the navigation bar when the user has logged in in the base template.

<img class="mx-auto w-1/2" src="{{site.baseurl}}/assets/img/orgNotesImages/django-profile.png">

However, if we log out, there is *nothing* that prevents us from opening the */profile/* page.

If we choose to do this now, the profile page will still open, albeit there would be nothing printed because the *user* attribute is empty.

This case requires us to put in a restriction in our profile view.

For the restriction, we can easily use a decorator that Django provides for us. This decorator can be imported and used in our *users/views.py* module:

```python
from django.shortcuts import render, redirect
from django.contrib import messages
from .forms import UserRegisterForm
from django.contrib.auth.decorators import login_required

def register(request):
    if request.method == 'POST':
        form = UserRegisterForm(request.POST)
        if form.is_valid():
            form.save()
            username = form.cleaned_data.get('username')
            messages.success(request, f'Account created for {username}, log in now!')      
            return redirect('login')     
    else:
        form = UserRegisterForm()
    return render(request, 'users/register.html', {'form': form})


@login_required 
def profile(request):
    return render(request, 'users/profile.html')
```

The decorator adds additional functions to our existing function *profile()*.

After adding the decorator, if we navigate to */profile/*, we'd get a 404 because on default, the `@login_required` decorator tries to redirect us to */accounts/login/* page.

```

Page not found (404)
Request Method: 	GET
Request URL: 	http://localhost:8000/accounts/login/?next=/profile/

Using the URLconf defined in django_project.urls, Django tried these URL patterns, in this order:

    admin/
    [name='blog-home']
    about/ [name='blog-about']
    register/ [name='register']
    login/ [name='login']
    logout/ [name='logout']
    profile/ [name='profile']

The current path, accounts/login/, didn't match any of these.

You're seeing this error because you have DEBUG = True in your Django settings file. Change that to False, and Django will display a standard 404 page.
```

We need to configure the route for the default login url to *our* one. This can be done in the *settings.py* module:
```python
LOGIN_URL = 'login'
```

Note that `'login'` is the name of our login page. This name has been set in the project *urls.py* module.

Now if we try to go to */profile/* without having logged in, we'd be redirected back to log in.

An important thing to note is that, this is not JUST the login page, but the URL is: http://localhost:8000/login/?next=/profile/, which includes the `?next` parameter,  which means after the user has logged in, they be redirected back to the profile page. This feature is very useful and is built-in in most recent web development framework.

* User Profile

At the end of the last episode we have configured our */profile/* page. Now we need to enhance it because at current it only shows the username attribute.

** User Profile Picture

By default, the django-provided user module does not have a field for the profile picture.

Therefore, we need to create a new model profile that has a *one-to-one* relationship with the user module. This means that each user has one profile and one profile corresponds to one user.

This can be created in our *users/models.py* module:
```python
from django.db import models
from django.contrib.auth.models import User

class Profile(models.Model):  
    # Create one-to-one relationship
    # On delete of User, delete the profile
    user = models.OneToOneField(User, on_delete=models.CASCADE)
    
    image = models.ImageField(default='default.jpg', upload_to='profile_pics')
    
    def __str__(self):
        return f'{self.user.username} Profile'
```

Remember that, the power of Python Django is its migration function which allows us to easily make changes to migrations. We need to make the migration whenever we change our model.

Therefore we need to run `python manage.py makemigrations`. However we'd get an error with the `ImageField` method.
```sh
▶ python manage.py makemigrations
SystemCheckError: System check identified some issues:

ERRORS:
users.Profile.image: (fields.E210) Cannot use ImageField because Pillow is not installed.
        HINT: Get Pillow at https://pypi.org/project/Pillow/ or run command "pip install Pillow".
```

*Pillow* is a library that allows us to work with images in Python. All we need to do is:
```sh
Projects/django-env/django_project                                                                                                                                                             ⍉
▶ pip install Pillow
Collecting Pillow
  Downloading https://files.pythonhosted.org/packages/89/3e/31c2e5385d7588016c6f7ac552e81c3fff2bef4bc61b6f82f8177752405c/Pillow-6.2.1-cp37-cp37m-manylinux1_x86_64.whl (2.1MB)
     |████████████████████████████████| 2.1MB 2.0MB/s 
Installing collected packages: Pillow
Successfully installed Pillow-6.2.1
```

then.. again..
```sh
▶ python manage.py makemigrations
Migrations for 'users':
  users/migrations/0001_initial.py
    - Create model Profile
```

The migration has been created. Now we need to run `python manage.py migrate` to update the database.

** Looking at Profile on Admin page

Something that is very easy to *forget* is that we have to register our newly created model in our app *admin.py* module. This allows us to see the Profile model in our Admin module, i.e *users/admin.py*:

```python
from django.contrib import admin
from .models import Profile

admin.site.register(Profile)
```

If we open our admin page now we should be able to see Profile. However there is no profile yet because the existing users on the system don't have any profile. We can then just *add Profile* and link it to a User.

<img class="mx-auto w-1/2" src="{{site.baseurl}}/assets/img/orgNotesImages/django-create-profile.png">

** Looking at User Profile via Django Shell

We can interact with our user model via Django shell.

<img class="mx-auto w-1/2" src="{{site.baseurl}}/assets/img/orgNotesImages/django-user-shell1.png">


<img class="mx-auto w-1/2" src="{{site.baseurl}}/assets/img/orgNotesImages/django-user-shell2.png">


Key thing is, we can access the URL of the image via `user.profile.image.url`.

Note that if duplicate files are uploaded, their name would be hashed.


** Back to our project

If we go back to project, we can see that a directory *profile_pics* in our root directory, along with other apps. This is the name that we have passed to our model.

This location is not ideal and we should change some settings to change the location of the *profile_pics* directory.

We can do this in our *settings.py* module where we need to configure two additional settings variable *MEDIA_ROOT* and *MEDIA_URL*. These two settings control the location for uploaded files.

*MEDIA_ROOT* controls the absolute filesystem path to the directory that will hold *user-uploaded files*. Essentially it's an internal setting that controls where uploaded files go.

*MEDIA_ROOT must be different from *STATIC_URL*, since sharing these two paths can expose our system security.

*MEDIA_URL* controls the URL that handles the media served from *MEDIA_ROOT*, used for managing *stored files*. If we set it as a non-empty value, it must ends with a slash. This is the public url that can be accesed via the web browser.

*settings.py*
```python
MEDIA_ROOT = os.path.join(BASE_DIR, 'media')
MEDIA_URL = '/media/'
```

Note that these new settings will not be applied to our existing user profiles, so we just need to delete them, before re-creating new ones.

After we create a new profile and upload an image, the image is now being saved in the */media/profile_pics* folder.
<img class="mx-auto w-1/2" src="{{site.baseurl}}/assets/img/orgNotesImages/django-dir-aftermedia.png">

The old *profile_pics* will still be there. We can just delete it.

** Displaying the profile picture in profile page

Back to our *profile.html* which is currently:
```html
{% extends "blog/base.html" %}
{% load crispy_forms_tags %}

{% block content %}
    <h1>{{ user.username }}</h1>
{% endblock content%}
```

We want this profile page to have all the things, so we need to change it.

*profile.html*
```html
{% extends "blog/base.html" %}
{% load crispy_forms_tags %}

{% block content %}
    <div class="content-section">
        <div class="media">
            <img class="rounded-circle account-img" src="{{ user.profile.image.url }}">
            <div class="media-body">
                <h2 class="account-heading">{{ user.username }}</h2>
                <p class="text-secondary">{{ user.email }}</p>
            </div>
        </div>
    </div>
{% endblock content%}
```

In order to configure how to serve static files to our users, we need configure some settings in our *settings.py* module. The settings that we are about to configure control the routing for uploaded media. There are multiple ways to serve uploaded media. However different methods should be used for development and production. On the Django doc site, different strategies are listed for us.

What we are going to do here is simply use the development deployment strategy that is instructed in the Django doc: [[https://docs.djangoproject.com/en/2.2/howto/static-files/#serving-files-uploaded-by-a-user-during-development][Serving files uploade by a user during development]].

Because we are only serving the files this way in DEBUG mode, we can write our settings this way:
*settings.py*
```python
from django.contrib import admin
from django.urls import path, include
from users import views as user_views
from django.contrib.auth import views as auth_views
from django.conf import settings
from django.conf.urls.static import static


urlpatterns = [
    path('admin/', admin.site.urls),
    path('', include('blog.urls')),
    path('register/', user_views.register, name='register'),
    path('login/', auth_views.LoginView.as_view(template_name='users/login.html'), name='login'),
    path('logout/', auth_views.LogoutView.as_view(template_name='users/logout.html'), name='logout'),
    path('profile/', user_views.profile, name='profile')
]

if settings.DEBUG:
    urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)
```

Now, our profile page is nice:
<img class="mx-auto w-1/2" src="{{site.baseurl}}/assets/img/orgNotesImages/django-profile-withpic.png">

** Setup User-Profile *signal*

This is simple and we can enable this by using django *signals*. We first need to configure it so that everytime a user is created, an associated profile is created as well. Then, we program our signal so that when a user is saved, the profile is also saved.

First of all we need to create a signal module: *users/signals.py*:
```python
from django.db.models.signals import post_save # this signal gets fired after an object is aved
from django.contrib.auth.models import User # this is the sender
from django.dispatch import receiver # this is the receiver
from .models import Profile 

@receiver(post_save, sender=User) 
# When a User is created, send the signal. Signal is then received by @receiver, which is handled by the following function:
def create_profile(sender, instance, created, **kwargs):
    '''
    This is responsible for the creation of a profile each time a new user is created.
    
    It takes all the arguments that post_save signal passes to it.
    One of those argument is the instance of the user, and one of those is created.
    '''
    
    if created:
        Profile.objects.create(user=instance)

@receiver(post_save, sender=User) 
def save_profile(sender, instance, **kwargs):
    '''
    This is responsible for the saving of a profile each time a user is saved.
    '''
    instance.profile.save()
```

Then we need to go to *users/apps.py* to import the signals into the `ready()` function of our users app. We just need to add a `ready()` function:

```python
from django.apps import AppConfig


class UsersConfig(AppConfig):
    name = 'users'

    def ready(self):
        import users.signals
```

This the recommended way of importing signals by Django.

Now if we create a new user, a new profile will automatically be created.

*** More about signals

The `django.db.models.signals` module defines a set of signals sent by the model system. This is quite powerful for a complex system that consists of decoupled applications.

`signals` enables apps to send signals between each other upon certain event happening for models.

Djago Signals are an implementation of the [[https://en.wikipedia.org/wiki/Observer_pattern][Observer Pattern]]. In such a design pattern, a subscription mechanism is implemented where multiple objects are subscribed to (or "observing") a particular object and any events that may happen to it. A good analogy is when someone likes your Facebook and you get a notification.

Through a "signal dispatcher", Django is able to distribute signals in a decoupled setup to registered "receivers" in the various system components. *Signals are registered and triggered when certain events occurs*, any listeners to that event will get notified that event has occured, alongside receiving some contextual data within the payload that may be relevant to the functionality of the receiver. A receiver can be any function, or method.

Within the `signals` module there are several built-in signals. One of those is `post_save` which sends a signal at the end of `save()` method.

With the `save()` signal, the following arguments are sent:

- *sender*
The model class.

- *instance*
The actual instance being saved.

- *created*
A boolean, *True* if a new record was created.

- *raw*
A boolean, *True* if the models is saved exactly as presented (i.e when loading a fixture).

- *using*
The database alias being used

- *update_fields*
The set of fields to update as passed to *Model.save()*, or *None* if *update_fields* wasn't passed to *save()*. 

* Update User Profile

** Create the form page

We need to do some setup to enable our users to be able to update their user profile in the profile page, including changing the profile picture. We also need to set it up so that uploaded images are automatically resized.

We need to create some forms. We do this within the *users/forms.py* module which currently holds our *UserRegisterForm*.

For this new form we are going to use *ModelForm*. ModelForm is used to create forms that map closely to Django models.

Previously for the UserRegisterForm, we simply inherited the default UserCreationForm and added an Email field. For the Update User Profile form, we'll do something similar and will have to define the *class Meta* that tells our form what model to work with.

Note that because the profile picture is in our Profile model, update of profile picture technically needs to be on a different form.

*users/forms.py*
```python
from django import forms
from django.contrib.auth.models import User 
from django.contrib.auth.forms import UserCreationForm
from .models import Profile

class UserRegisterForm(UserCreationForm):
    email = forms.EmailField() ## required=True is default
    
    class Meta:
        model = User ## Use the default User model. When save, save to User model
        fields = ['username', 'email', 'password1', 'password2'] ## These are going to be shown on our form, in THIS order.

class UserUpdateForm(forms.ModelForm):
    email = forms.EmailField()
    
    class Meta:
        model = User
        fields = ['username', 'email']
        
class ProfileUpdateForm(forms.ModelForm):
    class Meta:
        model = Profile
        fields = ['image']
```


Our UserUpdateForm will allow user to update username and email, whereas ProfileUpdateForm will allow user to update their image. Password change is not yet a thing for now.

With the two forms already created, we then configure our views page i.e *users/views.py*:
```python
from django.shortcuts import render, redirect
from django.contrib import messages
from .forms import UserRegisterForm, UserUpdateForm, ProfileUpdateForm
from django.contrib.auth.decorators import login_required

def register(request):
    if request.method == 'POST':
        form = UserRegisterForm(request.POST)
        if form.is_valid():
            form.save()
            username = form.cleaned_data.get('username')
            messages.success(request, f'Account created for {username}, log in now!')      
            return redirect('login')     
    else:
        form = UserRegisterForm()
    return render(request, 'users/register.html', {'form': form})


@login_required 
def profile(request):
    u_form = UserUpdateForm(instance=request.user)
    p_form = ProfileUpdateForm(instance=request.user.profile)
    context = {
        'u_form': u_form,
        'p_form': p_form
    }
    return render(request, 'users/profile.html', context)
```

Note that when we instantiate u_form and p_form, we can leave the arguments empty. However if we pass the instance in, the forms will be pre-filled with user's information.

With the context being passed into `profile()` which renders profile.html, we open the profile.html template and make some changes to expose our form elements. Although we have two forms, we can combine them both to make it look like one single form.

*profile.html*:
(what we did is copy the form bit within *register.html* and changed a few things here and there).
```html
{% extends "blog/base.html" %}
{% load crispy_forms_tags %}

{% block content %}
    <div class="content-section">
        <div class="media">
            <img class="rounded-circle account-img" width="150" src="{{ user.profile.image.url }}">
            <div class="media-body">
                <h2 class="account-heading">{{ user.username }}</h2>
                <p class="text-secondary">{{ user.email }}</p>
            </div>
        </div>
    <form method="POST" enctype="multipart/form-data">
            <!-- The csrf token adds an extra layer of security. It's a must-have for Django. -->
            {% csrf_token %}
            <fieldset class="form-group">
                <legend class="border-bottm mb-4">Update User Profile</legend>
                {{ u_form | crispy  }}
                {{ p_form | crispy  }}
            </fieldset>
            <div class="form-group">
                <button class="btn btn-outline-dark" type="submit">Update</button>
            </div>
        </form>
    </div>
{% endblock content%}
```

``````
*Important Note*: For our form to be handle image file properly, we have to add the attribute `enctype="multipart/form-data"` in otherwise it won't work and will be hard to debug. This attribute specifies how the form-data should be encoded when submitting it to the server. It can only be used if method="POST".
```

We now have a new profile page:

<img class="mx-auto w-1/2" src="{{site.baseurl}}/assets/img/orgNotesImages/django-update-profile.png">

** Configure POST request for User Update

Although our Profile Page now has the form, we have not configured our web page to handle POST request yet, i.e the submit button doesn't do anything.

So now we need to inprove our *users/views.py* module:
```python
from django.shortcuts import render, redirect
from django.contrib import messages
from .forms import UserRegisterForm, UserUpdateForm, ProfileUpdateForm
from django.contrib.auth.decorators import login_required

def register(request):
    if request.method == 'POST':
        form = UserRegisterForm(request.POST)
        if form.is_valid():
            form.save()
            username = form.cleaned_data.get('username')
            messages.success(request, f'Account created for {username}, log in now!')      
            return redirect('login')     
    else:
        form = UserRegisterForm()
    return render(request, 'users/register.html', {'form': form})

@login_required 
def profile(request):
    if request.method == 'POST':
        u_form = UserUpdateForm(request.POST, instance=request.user)
        p_form = ProfileUpdateForm(request.POST, 
                                   request.FILES,
                                   instance=request.user
                                   )
        if u_form.is_valid() and p_form.is_valid():
            u_form.save()
            p_form.save()
            messages.success(request, f'User profile {request.user.username} has been updated.')      
            return redirect('profile') 
    else:
        u_form = UserUpdateForm(instance=request.user)
        p_form = ProfileUpdateForm(instance=request.user.profile)
        
    context = {
        'u_form': u_form,
        'p_form': p_form
    }
    return render(request, 'users/profile.html', context)
```

Note that we want to redirect our user after a successful POST request. The reason for this is due to a POST-GET redirect pattern. This is the same thing when we reload after submitting a form, we are asked whether or not we want to resubmit the form When we redirect, we force the browser to send a *GET* request, to avoid that complication.

<img class="mx-auto w-1/2" src="{{site.baseurl}}/assets/img/orgNotesImages/django-profile-POST.png">

Note: It's a good practice after we send a POST request, to go into admin module to make sure that everything is OK.

** Automatically resizing image for User Update Form

Large images takes up additional space on our server. It also slows our webpage as the image needs to be sent via network.

For this we can use *Pillow*. Note that there are plenty of other ways to resize image, for this we are using the method of doing it via the *models.py* module, specifically via the `save()` method when a Profile is saved.

```python
from django.db import models
from django.contrib.auth.models import User
from PIL import Image
class Profile(models.Model):  
    # Create one-to-one relationship
    # On delete of User, delete the profile
    user = models.OneToOneField(User, on_delete=models.CASCADE)
    
    image = models.ImageField(default='default.jpg', upload_to='profile_pics')
    
    def __str__(self):
        return f'{self.user.username} Profile'
    
    def save(self):
        '''
        This method exists by default for any model. 
        However we need to add new things to automatically resize large images.
        '''
        super().save()  # Call the Parent save() method
        
        img = Image.open(self.image.path)
        
        if img.height > 300 or img.width > 300:
            output_size = (300,300)
            img.thumbnail(output_size)
            img.save(self.image.path)  # small image will override large image
```

** Enhance the blog home page

With the profile picture we can show user's image on blog home page, we just need to put in in our *blog/home.html*:

```html
<article class="media content-section">
    <img class="rounded-circle article-img" src ="{{ post.author.profile.image.url }}">
    <div class="media-body">
...
```

<img class="mx-auto w-1/2" src="{{site.baseurl}}/assets/img/orgNotesImages/django-blog-with-img.png">

** Our current project directory

This is our current project directory, at this stage:

```sh
Projects/django-env/django_project                                                                                                                                                               
▶ tree .
.
├── blog
│   ├── admin.py
│   ├── apps.py
│   ├── __init__.py
│   ├── migrations
│   │   ├── 0001_initial.py
│   │   ├── __init__.py
│   │   └── __pycache__
│   │       ├── 0001_initial.cpython-37.pyc
│   │       └── __init__.cpython-37.pyc
│   ├── models.py
│   ├── __pycache__
│   │   ├── admin.cpython-37.pyc
│   │   ├── apps.cpython-37.pyc
│   │   ├── __init__.cpython-37.pyc
│   │   ├── models.cpython-37.pyc
│   │   ├── urls.cpython-37.pyc
│   │   └── views.cpython-37.pyc
│   ├── static
│   │   └── blog
│   │       └── main.css
│   ├── templates
│   │   └── blog
│   │       ├── about.html
│   │       ├── base.html
│   │       └── home.html
│   ├── tests.py
│   ├── urls.py
│   └── views.py
├── db.sqlite3
├── django_project
│   ├── __init__.py
│   ├── __pycache__
│   │   ├── __init__.cpython-37.pyc
│   │   ├── settings.cpython-37.pyc
│   │   ├── urls.cpython-37.pyc
│   │   └── wsgi.cpython-37.pyc
│   ├── settings.py
│   ├── urls.py
│   └── wsgi.py
├── manage.py
├── media
│   ├── default.jpg
│   └── profile_pics
│       └── SmartRoku-square.jpg
└── users
    ├── admin.py
    ├── apps.py
    ├── forms.py
    ├── __init__.py
    ├── migrations
    │   ├── 0001_initial.py
    │   ├── __init__.py
    │   └── __pycache__
    │       ├── 0001_initial.cpython-37.pyc
    │       └── __init__.cpython-37.pyc
    ├── models.py
    ├── __pycache__
    │   ├── admin.cpython-37.pyc
    │   ├── apps.cpython-37.pyc
    │   ├── forms.cpython-37.pyc
    │   ├── __init__.cpython-37.pyc
    │   ├── models.cpython-37.pyc
    │   ├── signals.cpython-37.pyc
    │   └── views.cpython-37.pyc
    ├── signals.py
    ├── templates
    │   └── users
    │       ├── login.html
    │       ├── logout.html
    │       ├── profile.html
    │       └── register.html
    ├── tests.py
    └── views.py

18 directories, 56 files

```

* Create, Update and Delete Posts

In this chapter we are going to add the functionalities that enables user to add posts to the blog. We are going to be using *class-based* view to send POST request.

At this point we should be relatively familiar with function-based views which are configured in our *views.py* module. Essentially, certain URL patterns are routed to function-based views which handles the logic for our templates.

*Class-based views* have a lot more back-end functionalities that helps us define our application logic. There are different kinds of class-based views i.e list views, detailed views, create views, delete views..etc.

We are going back to our *blog app*. We are going to rewrite the function-based view for our blog-home page, i.e the file *blog/views.py*. We are going to create a *ListView*.

By default, class-based views look for templates with certain naming patterns. We can find out by creating a simple PostListView:

*blog/views.py*
```python
from django.shortcuts import render
from django.http import HttpResponse
from .models import Post
from django.views.generic import ListView


def home(request):
    context = {
        'posts': Post.objects.all()
    }
    return render(request, 'blog/home.html', context=context)

class PostListView(ListView):
    model = Post # For this ListView, deal with only Post model
    

def about(request):
    return render(request, 'blog/about.html', context={'title': 'Hello About'})
```

Then route the URL pattern that was previously pointed to home(), to this PostListView class-based view in *blog/urls.py*:
```python
from django.urls import path
from . import views

urlpatterns = [
    path('', views.PostListView.as_view(), name ='blog-home'),
    path('about/', views.about, name='blog-about')
]
```

if we browse to http://localhost:8000/ now, we would see an error.
```
TemplateDoesNotExist at /

blog/post_list.html

Request Method: 	GET
Request URL: 	http://localhost:8000/
Django Version: 	2.2.7
Exception Type: 	TemplateDoesNotExist
Exception Value: 	blog/post_list.html
```

We can see that Django is trying to look for *blog/post_list.html*. The naming convention is:
```
<app>/<model>_<viewtype>.html
```

We could create this template. However we can also change which template we'd like this view to use. We can do this within *views.py* by setting the *template_name* variable:
```python
class PostListView(ListView):
    '''
    On default, this will look for a template with the following format:
    <app>/<model>_<viewtype>.html
    '''
    
    model = Post # For this ListView, deal with only Post model
    template_name = 'blog/home.html' # Set custom template
```

At this stage, if we browse to our blog-home page, we'd see the *home.html* template yes, but it's empty. this is because in our function-based view previously, we passed the context for the posts attribute that is used in our template. This time we need to do the same.

```python
class PostListView(ListView):
    '''
    On default, this will look for a template with the following format:
    <app>/<model>_<viewtype>.html
    '''
    
    model = Post # For this ListView, deal with only Post model
    template_name = 'blog/home.html' # Set custom template
    context_object_name = 'posts'
```

Now our blog-home page looks like before, albeit the ordering of the post is wrong, i.e our oldest post is currently at the top.

<img class="mx-auto w-1/2" src="{{site.baseurl}}/assets/img/orgNotesImages/django-bloghome.png">

We can fix the sorting order of our post. We can do this by re-configuring our ListView class-based view. We simply use the `ordering` variable:
```python
....
class PostListView(ListView):
    '''
    On default, this will look for a template with the following format:
    <app>/<model>_<viewtype>.html
    '''
    
    model = Post # For this ListView, deal with only Post model
    template_name = 'blog/home.html' # Set custom template
    context_object_name = 'posts'
    ordering = ['-date_posted']

...   

```

So what is the difference between function and class based views? Although in some examples we dont save a lot of coding lines, class-based view is generally easier. In class-based view, we basically just set up variables, in contrast to function-based view, where we have to render the function and explicitly pass the information. Note that the variables are optional. We can essentially get the class-based view working with one single line of code, without setting the variables.

This is what we are going to do in the next step - PostDetailView.

*** About `context_object_name`

 The `context_object_name` is the human-understandable name of the context variable that specifies the name of the parameter to be accessed from our templates.

 If the `context_object_name` is not set, the default parameter is `object_list` in *ListView*. This is not a very friendly (or human-understandable name). The below table shows the differences in how the parameter is accessed from our template:

 | With `context_object_name = posts` | With default `context_object_name` |
 |----------------------------------+----------------------------------|
 |               <c>                |               <c>                |
 |     `{% for post in posts %}`      |  `{% for post in object_list %}`   |

** Setting up the PostDetailView

For the PostDetailView, we can copy the PostListView. However this time we are not going to set the variables and leave them on default:
```python
from django.views.generic import DetailView


class PostDetailView(DetailView):    
    model = Post # For this view, deal with only Post model
```
/(The only thing we specify is for the DetailView to interface with the Post model.)/

Next we need to configure the routing. For this example, we want Django to give each post a unique url in format *post/ID*, e.g post/1, post/2, post/3..etc. We can specify that in *blog/views.py:*
```python
from django.urls import path
from .views import PostListView, PostDetailView
from . import views

urlpatterns = [
    path('', PostListView.as_view(), name ='blog-home'),
    path('about/', views.about, name='blog-about'),
    path('post/<int:pk>/', PostDetailView.as_view(), name='post-detail')
]
```

As above, we have *not* specify the variable `template_name`, due to this reason, our template file will need to be named *blog/post_detail.html*.

Without overwriting `context_object_name`, its default name is `object` in *DetailView*.

*blog/post_detail.html*
```html
{% extends "blog/base.html" %}

{% block content %}
    <article class="media content-section">
        <img class="rounded-circle article-img" src ="{{ object.author.profile.image.url }}">
        <div class="media-body">
            <div class="article-metadata">
                <a class="mr-2" href="#"> {{ object.author }}</a>
                <small class="text-muted">{{ object.date_posted | date:"Y M, d" }}</small>
            </div>
            <h2 class="article-title"> {{ object.title }}</h2>
            <p class="article-content">{{ object.content }}</p>
        </div>
    </article>
{% endblock content %}
```

Now, if we go to http://localhost:8000/post/1:
<img class="mx-auto w-1/2" src="{{site.baseurl}}/assets/img/orgNotesImages/post-1.png">

Of course, now with the individual post page, we can change *blog/home.html* so that the URLs on indidual post go to the detail view page.
```html
<h2> <a class="article-title" href="{ url 'post-detail' post.id }">{{ post.title }}</a></h2>
```
 
** CreateView

First we need to import *CreatView* from *django.views.generic*. This is the same library which we can import other views such as ListView, DetailView.. Then we use this CreateView to make a class-based view:

```python
from django.views.generic import CreateView

class PostCreateView(CreateView):
    # Date Posted will be populated automatically.
    
    model = Post
    fields = ['title', 'content']
```

Then we need to edit *urls.py*:
```python
from django.urls import path
from .views import PostListView, PostDetailView, PostCreateView
from . import views

urlpatterns = [
    path('', PostListView.as_view(), name ='blog-home'),
    path('about/', views.about, name='blog-about'),
    path('post/<int:pk>/', PostDetailView.as_view(), name='post-detail'),
    path('post/new/', PostCreateView.as_view(), name='post-create')
```

Now we need to think about the template for this PostCreateView. It is however not the something like /post_create/, similarly to post_detail. The expected name is in the format: `<name of model>_form`. This format is applicable to both CreateView and UpdateView, which we'll deal with later.

Knowing this, we'll create a new template file: *blog/post_form.html*. The template will be somewhat similar to *register.html*.

```html
{% extends "blog/base.html" %}
{% load crispy_forms_tags %}

{% block content %}
    <div class="content-section">
        <form method="POST">
            <!-- The csrf token adds an extra layer of security. It's a must-have for Django. -->
            {% csrf_token %}
            <fieldset class="form-group">
                <legend class="border-bottm mb-4">Blog Post</legend>
                {{ form | crispy  }}
            </fieldset>
            <div class="form-group">
                <button class="btn btn-outline-dark" type="submit">Post</button>
            </div>
        </form>
    </div>
{% endblock content%}
```

Now, if we go to http://localhost:8000/post/new, we can see:

<img class="mx-auto w-1/2" src="{{site.baseurl}}/assets/img/orgNotesImages/new post.png">

This is looking really good already. It showcases how powerful class-based views can be. All we did with this PostCreateView was just setting some fields and telling the class which model to use.

This view isn't really working however, if we were to create a post, we'd get a `IntegrityError` error.
```
IntegrityError at /post/new/

NOT NULL constraint failed: blog_post.author_id

Request Method: 	POST
Request URL: 	http://localhost:8000/post/new/
Django Version: 	2.2.7
Exception Type: 	IntegrityError
Exception Value: 	

NOT NULL constraint failed: blog_post.author_id
```

The reason that we are getting this error is because the post we are creating does not have an author. We need to fix this by adding the author to the form. What we need to do is create a method within our class-based view to check for the validity of the form:

*blog/views.py*
```python
class PostCreateView(CreateView):
    # Date Posted will be populated automatically.
    
    model = Post
    fields = ['title', 'content']
    
    def form_valid(self, form):
        form.instance.author = self.request.user
        # Before submit form, set form author to current user.
        return super().form_valid(form)
```

If we come back to the page now and submit the post, we'd however get a new error:
```
ValueError at /post/new/

Cannot assign "<SimpleLazyObject: <django.contrib.auth.models.AnonymousUser object at 0x7f7325684f98>>": "Post.author" must be a "User" instance.

Request Method: 	POST
Request URL: 	http://localhost:8000/post/new/
Django Version: 	2.2.7
Exception Type: 	ValueError
Exception Value: 	

Cannot assign "<SimpleLazyObject: <django.contrib.auth.models.AnonymousUser object at 0x7f7325684f98>>": "Post.author" must be a "User" instance.
```

This error indicates that we haven't logged in. So, after we log in and try to create a post, we'd get a different error:

```
ImproperlyConfigured at /post/new/

No URL to redirect to.  Either provide a url or define a get_absolute_url method on the Model.

Request Method: 	POST
Request URL: 	http://localhost:8000/post/new/
Django Version: 	2.2.7
Exception Type: 	ImproperlyConfigured
Exception Value: 	

No URL to redirect to.  Either provide a url or define a get_absolute_url method on the Model.
```

This error indicates that the post is created successfully, however Django does not know where to redirect us after this action. As a matter of fact, if we come back to the homepage now, we can see the post that we have just created.

Now we just need to edit our class-based view to let Django know where to go after the post has been created. Normally, Django would try to go to the DetailView of the post that has just been created, however it does not know how to. This behaviour is what we'd want as well. We have to tell it how to.

Note about the error message:
```
Either provide a url or define a get_absolute_url method on the Model.
```

We can refer to this and create a `get_absolute_url` method. This can be done within our *blog/models.py* module. For this, we'll be using the reverse URL function. 

Reverse URLs are different to Redirect URLs. Redirect redirect us to a specific route. Reverse simply return a URL to *as a string*.

*blog/models.py*:
```python
from django.db import models
from django.utils import timezone
from django.contrib.auth.models import User
from django.urls import reverse

class Post(models.Model):
    title = models.CharField(max_length=100)
    content = models.TextField() # Unrestricted text
    date_posted = models.DateTimeField(default=timezone.now)
    # (For the above we can also do DateTimeField(auto_now_add = True) 
    author = models.ForeignKey(User, on_delete=models.CASCADE)
    # This specifies a many-to-one relationship
    # Also, on delete of user, also delete the post(s) as well
    
    def __str__(self):
        return self.title
    
    def get_absolute_url(self):
        return reverse('post-detail', kwargs={'pk': self.pk})

```

Now if we create our post, we'd be redirected to the post-detail route. The post would be created, we didn't change this behaviour at all.

Another enhancement that we should make is preventing non-logged in sessions from being able to access this create view. We did the same thing with function-based view back in *users/views.py*, where we added a `@login_required` decorator.
```python
@login_required 
def profile(request):
...
```

With class-based view, however, we are unable to add the decorator. We need to add a "login mixin". We do this in *blog/views.py*. We just need to add this to the (parent/super) classes that we are inhering from, when we create our PostCreateView.

This LoginRequriredMixin should be added to the far left.
```python
...
from django.contrib.auth.mixins import LoginRequiredMixin
...
class PostCreateView(LoginRequiredMixin, CreateView):
    # Date Posted will be populated automatically.
    
    model = Post
    fields = ['title', 'content']
...
```

With just this, now if we log out, then go to http://localhost:8000/post/new, we'd be redirected to the Login view. 

** UpdateView

This would be somewhat similar to the PostCreateView. We can actually leave it exactly the same in term of model, fields and post save method.


*blog/views.py*:
```python
from django.views.generic import (
    ListView, 
    DetailView, 
    CreateView, 
    UpdateView
)

class PostUpdateView(LoginRequiredMixin, UpdateView):
    
    model = Post
    fields = ['title', 'content']
    
    def form_valid(self, form):
        form.instance.author = self.request.user
        # Before submit form, set form author to current user.
        return super().form_valid(form)

```

*blog/urls.py*
```python
from django.urls import path
from .views import (
    PostListView, 
    PostDetailView, 
    PostCreateView,
    PostUpdateView
)
from . import views

urlpatterns = [
    path('', PostListView.as_view(), name ='blog-home'),
    path('about/', views.about, name='blog-about'),
    path('post/<int:pk>/', PostDetailView.as_view(), name='post-detail'),
    path('post/new/', PostCreateView.as_view(), name='post-create'),
    path('post/<int:pk>/update/', PostUpdateView.as_view(), name='post-update')
]
```

In regards to the template, this PostUpdateView actually uses the same template as the one we use for PostCreate which is *post_form.html*. So we don't even need to add another template.

With what we have done, if we navigate to http://localhost:8000/post/5/update/ we can see the view. This view would also actually work.

At this stage, we have a security loop-hole.

Although we have a check to only allow logged-in users to post and edit posts, we don't have anything that checks whether or not the update is being done by the author. This means 'Post-X' which was written by 'Author-X' could be updated by another 'Author-Y'.

To solve this problem, we can use a Mixin. Again, this mixin class will need to be inherited by our PostUpdateView class.

*blog/views.py*:
```python
...
from django.contrib.auth.mixins import LoginRequiredMixin, UserPassesTestMixin
...
class PostUpdateView(LoginRequiredMixin, UserPassesTestMixin, UpdateView):
    
    model = Post
    fields = ['title', 'content']
    
    def form_valid(self, form):
        form.instance.author = self.request.user
        # Before submit form, set form author to current user.
        return super().form_valid(form)
    
    def test_func(self):
        post = self.get_object()
        if self.request.user == post.author:
            return True
        return False

```

Note that the *UserPassesTestMixin* is inherited *after* the LoginRequiredMixin. This means a user must first be logged in and then they must pass the user test before accessing the *PostUpdateView* class-based view. Generally, this positioning is better because it indicates permission settings first start with a general one then become a more granular one as we move along to the right.

The `test_func` method is used by `UserPassesTestMixing` for our logic. What happened here is that when we create the PostUpdateView, we set a default test_func method by simply inhering UserPassesTestMixin. We simply overrode it as we needed to. In this case, we set the variable `post` to the current object returned by `self.get_object()`. Then we take the `author` on the current object and compare it against the current user. The current user is retrieve via the request object.

If we now log in as a user and try to open the UpdateView on another user's post, we'd get `403 Forbidden`.

** DeleteView

Our DeleteView can be very similar to DetailView. There are two things that we need to program:
- Current user needs to be logged in to use this view.
- The current user must be the author of the post being deleted.

For the two rules above to be implemented, again we'll just use the mixins that we used in our PostUpdateView. We'd also need to override the `test_func()` function.


Similarly to the other views, we go into *blog/views.py* and...

```python
from django.views.generic import (
    ListView, 
    DetailView, 
    CreateView, 
    UpdateView,
    DeleteView
)
...
class PostDeleteView(LoginRequiredMixin, UserPassesTestMixin,DeleteView):    
    model = Post
    def test_func(self):
        post = self.get_object()
        if self.request.user == post.author:
            return True
        return False
```

as well as setting the routing in *blog/urls.py*..
```python
from django.urls import path
from .views import (
    PostListView, 
    PostDetailView, 
    PostCreateView,
    PostUpdateView,
    PostDeleteView
)
from . import views

urlpatterns = [
    path('', PostListView.as_view(), name ='blog-home'),
    path('about/', views.about, name='blog-about'),
    path('post/<int:pk>/', PostDetailView.as_view(), name='post-detail'),
    path('post/new/', PostCreateView.as_view(), name='post-create'),
    path('post/<int:pk>/update/', PostUpdateView.as_view(), name='post-update'),
    path('post/<int:pk>/delete/', PostDeleteView.as_view(), name='post-delete')
]
```

and then the template in *blog/templates/blog/post_confirm_delete.html*. This template although has a different name, will be similar to the others. Also, as there will be no form, we can remove the form bits as well as as cripy form.
```html
{% extends "blog/base.html" %}

{% block content %}
    <div class="content-section">
        <form method="POST">
            <!-- The csrf token adds an extra layer of security. It's a must-have for Django. -->
            {% csrf_token %}
            <fieldset class="form-group">
                <legend class="border-bottm mb-4">Delete Post</legend>
                <h2>Are you sure you want to delete the post "{{ object.title }}"</h2>
            </fieldset>
            <div class="form-group">
                <button class="btn btn-outline-danger" type="submit">Yes, Delete</button>
                <a class="btn btn-outline-secondary" href="{% url 'post-detail' object.id %}">No, Cancel</a>
            </div>
        </form>
    </div>
{% endblock content%}
```

Now if we go to, say, http://localhost:8000/post/5/delete, we see:
<img class="mx-auto w-1/2" src="{{site.baseurl}}/assets/img/orgNotesImages/post-delete.png">

However, if we hit the 'Yes, Delete' button, we'd get an error:
```
ImproperlyConfigured at /post/5/delete/

No URL to redirect to. Provide a success_url.

Request Method: 	POST
Request URL: 	http://localhost:8000/post/5/delete/
Django Version: 	2.2.7
Exception Type: 	ImproperlyConfigured
Exception Value: 	

No URL to redirect to. Provide a success_url.
```

Note that when we receive this error, the deletion actually does go through sucessfully i.e if we go back to our homepage, the post is still there.

To fix this up, we need to only define the variable `success_url` in our view..
```python
...
class PostDeleteView(LoginRequiredMixin, UserPassesTestMixin, DeleteView):    
    model = Post
    success_url = '/'
    def test_func(self):
        post = self.get_object()
        if self.request.user == post.author:
            return True
        return False
...
```

As we have set `success_url = '/'`, when we delete a post and confirm, we are simply redirected to the Homepage.

** Touch Up

At this stage we have successfully create CreateView, UpdateView, and DeleteView. However we haven't programmed these URLs on our page, i.e we still have to go to the urls directly.

In our *base.html*, we want to give logged in user the ability to Create Post:

```html
...
                        <div class="navbar-nav">
                            {% if user.is_authenticated %}
                                <a class="nav-item nav-link" href="{% url 'post-create' %}">New Post</a>
                                <a class="nav-item nav-link" href="{% url 'profile' %}">Profile</a>
                                <a class="nav-item nav-link" href="{% url 'logout' %}">Logout</a>
                            {% else %}
                                <a class="nav-item nav-link" href="{% url 'login' %}">Login</a>
                                <a class="nav-item nav-link" href="{% url 'register' %}">Register</a>
                            {% endif %}
                        </div>
...
```

as well as giving Post-Update and Post-Delete urls in *post_detail.html*. The new elements that we are inserting will be wrapped right below the author and date bit. We also have to implement a *conditional* clause to make sure that the Update and Delete options are only visible to logged-in user who is also the author of the post we are looking at.

```html
            <div class="article-metadata">
                <a class="mr-2" href="#"> {{ object.author }}</a>
                <small class="text-muted">{{ object.date_posted | date:"Y M, d" }}</small>
                {% if object.author == user %}
                    <div align="right">
                        <a class="btn btn-secondary btn-sm mt-1 mb-1" href="{% url 'post-update' object.id %}">Update</a>
                        <a class="btn btn-danger btn-sm mt-1 mb-1" href="{% url 'post-delete' object.id %}">Delete</a>
                    </div>
                {% endif %}
            </div>
```
* Pagination

** Introduction
 By adding some pagination, we are adding some functionalities to our site. We'd also be creating a pagination for each user profile.

 First, we need to spam and make a bunch of additional posts. We can do this by just spamming the Post-Create view. However we could also do this via a json file.

 Let's say we have a *posts.json* file in our project folder *django_project/posts.json*. We can then use *Django-shell* to add these posts to our page.

 <img class="mx-auto w-1/2" src="{{site.baseurl}}/assets/img/orgNotesImages/post-using-json.png">

 Now we go back to our homepage and see a bunch of random posts:
 <img class="mx-auto w-1/2" src="{{site.baseurl}}/assets/img/orgNotesImages/random-posts.png">
 These posts, at the moment are all on a single page. This demonstrates that we kinda need pagination to improve usability. If we add images and media on posts, having them all on a single page could also impact the performance of the page itself.

 Before implementing Paginator on our page, we can actually play around with in in django shell.

 <img class="mx-auto w-1/2" src="{{site.baseurl}}/assets/img/orgNotesImages/paginator-start.png">

 We can also iterate through the pages:

 <img class="mx-auto w-1/2" src="{{site.baseurl}}/assets/img/orgNotesImages/paginator-1.png">

 We can also look at specific page:

 <img class="mx-auto w-1/2" src="{{site.baseurl}}/assets/img/orgNotesImages/paginator-2.png">

 Probably one of the more important things in the topic of Paginator, we want to see whether or not there is a previous or next page to a specific page:

 <img class="mx-auto w-1/2" src="{{site.baseurl}}/assets/img/orgNotesImages/paginator-3.png">

 or..
 <img class="mx-auto w-1/2" src="{{site.baseurl}}/assets/img/orgNotesImages/paginator-4.png">




** Pagination

Now that we know how Paginator behaves, we can open up our *blog/views.py* module to start paginating. Specifically, we are going to work on the PostListView class-based view.

If we simply add a variable in our PostListView class - `paginate_by = 2`:
```python
...
class PostListView(ListView):
    '''
    On default, this will look for a template with the following format:
    <app>/<model>_<viewtype>.html
    '''
    
    model = Post # For this ListView, deal with only Post model
    template_name = 'blog/home.html' # Set custom template
    context_object_name = 'posts'
    ordering = ['-date_posted']
    paginate_by= 2 
...
```

We can see that our Post List View only has two posts, right off the bat. One thing to note though is that there is no page url yet.

<img class="mx-auto w-1/2" src="{{site.baseurl}}/assets/img/orgNotesImages/post-paged2.png">

However, we can actually go the other pages by typing in the url in the follow format: http://localhost:8000/?page=x, for example:

- http://localhost:8000/?page=3:
<img class="mx-auto w-1/2" src="{{site.baseurl}}/assets/img/orgNotesImages/post-page3.png">

So.. we only need to only add the page urls to our templates now. We do this in *blog/templates/blog/home.html*, which is the template of our PostListView. In this we simply add the pagination after our for post loop. There is a lot of if and for loops. However when we are done, it all comes together.

*home.html*
```html
{% extends "blog/base.html" %}

{% block content %}
    {% for post in posts %}
        <!-- <h1>{{ post.title }}</h1>
        <p>By {{ post.author }} on {{post.date_posted}}</p>
        <p>{{ post.content}}</p> -->

        <article class="media content-section">
            <img class="rounded-circle article-img" src ="{{ post.author.profile.image.url }}">
            <div class="media-body">
                <div class="article-metadata">
                    <a class="mr-2" href="#"> {{ post.author }}</a>
                    <small class="text-muted">{{ post.date_posted | date:"Y M, d" }}</small>
                </div>
                <h2> <a class="article-title" href="{% url 'post-detail' post.id %}">{{ post.title }}</a></h2>
                <p class="article-content">{{ post.content }}</p>
            </div>
        </article>
    {% endfor %}
    <div align="right">
        {% if is_paginated %}
            {% if page_obj.has_previous %}
                <a class="btn btn-sm btn-outline-info mb-4" href="?page=1">First</a>
                <a class="btn btn-sm btn-outline-info mb-4" href="{{ page_obj.previous_page_number }}">Previous</a>
            {% endif %}
            {% for num in page_obj.paginator.page_range %}
                {% if page_obj.number == num %}
                    <a class="btn btn-sm btn-info mb-4" href="?page={{ num }}">{{ num }}</a>
                {% elif num > page_obj.number|add:'-3' and num < page_obj.number|add:'3' %}
                    <a class="btn btn-sm btn-outline-info mb-4" href="?page={{ num }}">{{ num }}</a>
                {% endif %}
            {% endfor %}
            {% if page_obj.has_next %}
                <a class="btn btn-sm btn-outline-info mb-4" href="?page={{ page_obj.next_page_number }}">Next</a>
                <a class="btn btn-sm btn-outline-info mb-4" href="?page={{ page_obj.paginator.num_pages }}">Last</a>
            {% endif %}
        {% endif %}
    </div> 
{% endblock content %}

```

Note about the *page_obj* bit, this is the page object that our view passes into our template. 

Back to our page, say if we go to page 2:

<img class="mx-auto w-1/2" src="{{site.baseurl}}/assets/img/orgNotesImages/blog-page-2.png">

So our pagination is pretty much done. However 2 post per page is a bit ridiculous, so we update `paginate_by = 5` in our PostListView. 





** User post Link

Right now, our author url is dead. We are going to build a page to display all posts by any author. If the user has a bunch of post, the view is paginated as well.

This view is very similar to our PostListView, albeit only for a single user. So we start with *blog/views.py*..

Note that we don't want a page that shows all post but have a filter for only the linked user. This will come via the URL that Django handles, i.e it will be specified via the *url pattern*. First, let's assume that we just have a username variable passed into the URL. Then we need to overried a method that's called `get_queryset()` that will query the author.

We have to also import two additional things: `get_object_or_404` and the `User` model. The `get_object_or_404` does exactly what it advertises. It retrieves an object. if the object does not exist, it returns a 404.

*blog/views.py*
```python
from django.shortcuts import render, get_object_or_404
from django.contrib.auth.models import User
from django.http import HttpResponse
from .models import Post
from django.views.generic import (
    ListView, 
    DetailView, 
    CreateView, 
    UpdateView,
    DeleteView
)
from django.contrib.auth.mixins import LoginRequiredMixin, UserPassesTestMixin



def home(request):
    context = {
        'posts': Post.objects.all()
    }
    return render(request, 'blog/home.html', context=context)

class PostListView(ListView):
    '''
    On default, this will look for a template with the following format:
    <app>/<model>_<viewtype>.html
    '''
    
    model = Post # For this ListView, deal with only Post model
    template_name = 'blog/home.html' # Set custom template
    context_object_name = 'posts'
    ordering = ['-date_posted']
    paginate_by= 5

class UserPostListView(ListView):
    '''
    On default, this will look for a template with the following format:
    <app>/<model>_<viewtype>.html
    '''
    
    model = Post # For this ListView, deal with only Post model
    template_name = 'blog/user_posts.html' # Set custom template
    context_object_name = 'posts'
    paginate_by= 5
    
    def get_queryset(self):
        user = get_object_or_404(User, username=self.kwargs.get('username'))
        return Post.objects.filter(author=user).order_by('-date_posted')
        
    
class PostDetailView(DetailView):    
    model = Post
    
class PostCreateView(LoginRequiredMixin, CreateView):
    # Date Posted will be populated automatically.
    
    model = Post
    fields = ['title', 'content']
    
    def form_valid(self, form):
        form.instance.author = self.request.user
        # Before submit form, set form author to current user.
        return super().form_valid(form)
    
class PostUpdateView(LoginRequiredMixin, UserPassesTestMixin, UpdateView):
    
    model = Post
    fields = ['title', 'content']
    
    def form_valid(self, form):
        form.instance.author = self.request.user
        # Before submit form, set form author to current user.
        return super().form_valid(form)
    
    def test_func(self):
        post = self.get_object()
        if self.request.user == post.author:
            return True
        return False
    
class PostDeleteView(LoginRequiredMixin, UserPassesTestMixin, DeleteView):    
    model = Post
    success_url = '/'
    def test_func(self):
        post = self.get_object()
        if self.request.user == post.author:
            return True
        return False

def about(request):
    return render(request, 'blog/about.html', context={'title': 'Hello About'})
```

Then we can do the routing in *blog/urls.py*:
```python
from django.urls import path
from .views import (
    PostListView, 
    PostDetailView, 
    PostCreateView,
    PostUpdateView,
    PostDeleteView,
    UserPostListView
)
from . import views

urlpatterns = [
    path('', PostListView.as_view(), name ='blog-home'),
    path('about/', views.about, name='blog-about'),
    path('post/<int:pk>/', PostDetailView.as_view(), name='post-detail'),
    path('post/new/', PostCreateView.as_view(), name='post-create'),
    path('post/<int:pk>/update/', PostUpdateView.as_view(), name='post-update'),
    path('post/<int:pk>/delete/', PostDeleteView.as_view(), name='post-delete'),
    ath('user/<str:username>', UserPostListView.as_view(), name ='user-posts')
]
```

and then we need to create the new template *blog/templates/blog/user_posts.html*. This template is very similar to *home.html*:

```html
{% extends "blog/base.html" %}

{% block content %}
    <h1 class="mb-3">Posts by {{ view.kwargs.username }} ({{ page_obj.paginator.count }})</h1>
    {% for post in posts %}
        <!-- <h1>{{ post.title }}</h1>
        <p>By {{ post.author }} on {{post.date_posted}}</p>
        <p>{{ post.content}}</p> -->

        <article class="media content-section">
            <img class="rounded-circle article-img" src ="{{ post.author.profile.image.url }}">
            <div class="media-body">
                <div class="article-metadata">
                    <a class="mr-2" href="{% url 'user-posts' post.author.username %}"> {{ post.author }}</a>
                    <small class="text-muted">{{ post.date_posted | date:"Y M, d" }}</small>
                </div>
                <h2> <a class="article-title" href="{% url 'post-detail' post.id %}">{{ post.title }}</a></h2>
                <p class="article-content">{{ post.content }}</p>
            </div>
        </article>
    {% endfor %}
    <div align="right">
        {% if is_paginated %}
            {% if page_obj.has_previous %}
                <a class="btn btn-sm btn-outline-info mb-4" href="?page=1">First</a>
                <a class="btn btn-sm btn-outline-info mb-4" href="{{ page_obj.previous_page_number }}">Previous</a>
            {% endif %}
            {% for num in page_obj.paginator.page_range %}
                {% if page_obj.number == num %}
                    <a class="btn btn-sm btn-info mb-4" href="?page={{ num }}">{{ num }}</a>
                {% elif num > page_obj.number|add:'-3' and num < page_obj.number|add:'3' %}
                    <a class="btn btn-sm btn-outline-info mb-4" href="?page={{ num }}">{{ num }}</a>
                {% endif %}
            {% endfor %}
            {% if page_obj.has_next %}
                <a class="btn btn-sm btn-outline-info mb-4" href="?page={{ page_obj.next_page_number }}">Next</a>
                <a class="btn btn-sm btn-outline-info mb-4" href="?page={{ page_obj.paginator.num_pages }}">Last</a>
            {% endif %}
        {% endif %}
    </div> 
{% endblock content %}
```

We'd also be touch up the *home.html* template a little bit to also have a working URL for the author link:

*home.html*
```html
...
                <div class="article-metadata">
                    <a class="mr-2" href="{% url 'user-posts' post.author.username %}"> {{ post.author }}</a>
                    <small class="text-muted">{{ post.date_posted | date:"Y M, d" }}</small>
                </div>
...
```

Our UserPostList is ready:

<img class="mx-auto w-1/2" src="{{site.baseurl}}/assets/img/orgNotesImages/userpostlist.png">
** posts.json
 ```json
 [
   {
     "title": "My Updated Post",
     "content": "My first updated post!\r\n\r\nThis is exciting!",
     "user_id": 1
   },
   {
     "title": "A Second Post",
     "content": "This is a post from a different user...",
     "user_id": 2
   },
   {
     "title": "Top 5 Programming Lanaguages",
     "content": "Te melius apeirian postulant cum, labitur admodum cu eos! Tollit equidem constituto ut has. Et per ponderum sadipscing, eu vero dolores recusabo nec! Eum quas epicuri at, eam albucius phaedrum ad, no eum probo fierent singulis. Dicat corrumpit definiebas id usu, in facete scripserit eam.\r\n\r\nVim ei exerci nusquam. Agam detraxit an quo? Quo et partem bonorum sensibus, mutat minimum est ad. In paulo essent signiferumque his, quaestio sadipscing theophrastus ad has. Ancillae appareat qualisque ei has, usu ne assum zril disputationi, sed at gloriatur persequeris.",
     "user_id": 1
   },
   {
     "title": "Sublime Text Tips and Tricks",
     "content": "Ea vix dico modus voluptatibus, mel iudico suavitate iracundia eu. Tincidunt voluptatibus pro eu? Nulla omittam eligendi his ne, suas putant ut pri. Ullum repudiare at duo, ut cum habeo minim laudem, dicit libris antiopam has ut! Ex movet feugait mea, eu vim impetus nostrud cotidieque.\r\n\r\nEi suas similique quo, his simul viris congue ex? Graeci possit in est, ne qui minim delectus invenire. Mei ad error homero maluisset, tacimates assentior per in, vix ut vocent accusata! Mei eu inermis pericula patrioque? Debet denique sea at, ad cibo reformidans theophrastus per, cu inermis maiestatis vim!\r\n\r\nUt odio feugiat voluptua est, euismod volutpat qualisque at sit, has ex dicit ornatus inimicus! Eu ferri laoreet vel, dicat corrumpit dissentias nec in. Illum dissentiunt eam ei, praesent voluptatum pri in? Ius in inani petentium, hinc elitr vivendum an vis, in vero dolores electram ius?",
     "user_id": 1
   },
   {
     "title": "Best Python IDEs",
     "content": "Elit contentiones nam no, sea ut consul adipiscing. Etiam velit ei usu, sonet clita nonumy eu eum. Usu ea utroque facilisi, cu mel fugit tantas legimus, te vix quem nominavi. Prima deserunt evertitur ne qui, nam reprimique appellantur ne.",
     "user_id": 1
   },
   {
     "title": "Flask vs Django - Which Is Better?",
     "content": "Ei dicta apeirian deterruisset eam, cu offendit invenire pri, cu possim vivendo vix? Nam nihil evertitur ad, ne vim nonumy legendos iracundia. Vix nulla dolorem intellegebat ea? Te per vide paulo dolor, eum ea erant placerat constituam? Dolores accumsan eum at.\r\n\r\nInteresset consequuntur id vix. Eam id decore latine, iusto imperdiet ei qui. In ludus consul reformidans eam. Nec in recusabo posidonium, cu tantas volumus mnesarchum pro. Nam ut docendi evertitur, possim menandri persecuti ne sed, cum saepe ornatus delenit ei?\r\n\r\nIn mel debet aliquam. In his etiam legere, doming nominavi consetetur has ad, decore reprimique ea usu. Eam magna graeci suavitate cu, facete delenit cum ne. Ponderum evertitur tincidunt ei mel, ius ei stet euismod docendi.",
     "user_id": 2
   },
   {
     "title": "You Won't Believe These Clickbait Titles!",
     "content": "Cu justo honestatis mel, pro ei appareat mediocrem suavitate. No his omnis ridens. Ludus ornatus voluptatum mei ut, an mentitum noluisse forensibus cum. Eam affert pertinax consequuntur ei, nisl zril meliore te vis? Ad animal persius concludaturque vix, eu graece audiam mel.\r\n\r\nVitae libris mentitum pri in. Cu rebum veritus sea, ex usu consul dolorum, pro tale maluisset consulatu ut. Quo ad clita persius ancillae. Vel illud blandit at, vel eu hinc graeco, usu doctus praesent ea! Vim rebum deserunt ex.\r\n\r\nIus lorem omittam id, est suavitate definitionem ad! Id vim insolens tacimates, pri at decore causae. Ex duo bonorum repudiandae? Vix no vidit facete impedit. An oportere indoctum eam.",
     "user_id": 2
   },
   {
     "title": "These Beers Will Improve Your Programming",
     "content": "Sanctus senserit vis id, ut eum iuvaret invidunt constituam? Nonumes facilis mei an, ad elit explicari persequeris pri, dico recusabo quo id? At mea lorem repudiandae. Sed causae sensibus forensibus ea, ne ornatus suscipiantur consectetuer mel, affert nostro nominati cu qui. Te sanctus constituto est, corrumpit pertinacia eos et, mei libris persequeris an.\r\n\r\nQuo fuisset sensibus in. Ad est assueverit adversarium, viris aperiri numquam est ad. Pro mediocrem iudicabit ei! Cu aperiam diceret sit.",
     "user_id": 1
   },
   {
     "title": "List of PyCon 2018 Talks",
     "content": "Has ea verear adolescens, elit justo constituam duo in, vix an copiosae contentiones. Eos persius consequuntur no, esse percipit cum ea, per modus harum praesent at. Et clita delenit luptatum usu? No cum interpretaris concludaturque. Congue pertinax ea mea.\r\n\r\nBrute iracundia philosophia ei quo, nam at adhuc idque, ex dolor homero mei. No mea affert tacimates pertinacia, in maluisset dissentias consectetuer mei, vel no aliquam splendide. In has nobis vocent adipisci? Pri clita delicata in, iusto viris scripserit vim in? Sit in lorem complectitur. Sanctus eloquentiam eum ut, et sumo apeirian mea? Vim te affert populo voluptaria, utinam consul ad duo.",
     "user_id": 1
   },
   {
     "title": "How Dogs in the Workplace Boosts Productivity",
     "content": "Has ea verear adolescens, elit justo constituam duo in, vix an copiosae contentiones. Eos persius consequuntur no, esse percipit cum ea, per modus harum praesent at. Et clita delenit luptatum usu? No cum interpretaris concludaturque. Congue pertinax ea mea.\r\n\r\nBrute iracundia philosophia ei quo, nam at adhuc idque, ex dolor homero mei. No mea affert tacimates pertinacia, in maluisset dissentias consectetuer mei, vel no aliquam splendide. In has nobis vocent adipisci? Pri clita delicata in, iusto viris scripserit vim in? Sit in lorem complectitur. Sanctus eloquentiam eum ut, et sumo apeirian mea? Vim te affert populo voluptaria, utinam consul ad duo.",
     "user_id": 1
   },
   {
     "title": "The Best Programming Podcasts",
     "content": "Vidisse malorum platonem vel no. Persecuti adversarium ut sit, quo et stet velit mundi! Id per homero expetenda. Est brute adipisci et!\r\n\r\nLorem aliquip has in, quo debet ceteros sadipscing ne! An sea odio ornatus inermis, an per ipsum persecuti dissentiunt, no mea bonorum pertinacia delicatissimi? Ne sumo diceret mea, percipit repudiare eam no! Pro et lorem accommodare. At eius novum phaedrum mei?\r\n\r\nIgnota conclusionemque mei no, eam ut munere fierent pertinacia. Ea enim insolens gloriatur duo, quis vituperatoribus pro no! Ei sed bonorum reprehendunt, aliquam nominavi his et. Magna decore referrentur id nec. Cum rebum ludus inimicus no, id cum iusto labores maluisset!\r\n\r\nQui no omnis numquam apeirian, et vide interesset cum? Et nec nulla signiferumque. Enim instructior eos ei, solum tollit phaedrum his in? No vix malorum ornatus, cu quo hinc everti iracundia, essent eruditi efficiendi ut nam. Altera saperet usu eu, errem expetenda cu duo. Has dolor splendide et, no mel cibo ancillae voluptatum, mutat antiopam deterruisset ei qui. Dolores scripserit concludaturque est id, ea animal facilisi splendide qui, quo at animal voluptua instructior.\r\n\r\nMeis voluptatum eu eum.",
     "user_id": 1
   },
   {
     "title": "Tips for Public Speaking",
     "content": "Ex eam doctus accommodare. Ut oratio vivendo intellegebat qui. Ius ne doming petentium. Pri congue delectus ad, accumsan molestiae disputando te mea. Nam case inani eligendi at, per te esse iudico. Feugiat patrioque mei ad, harum mundi adversarium an per!\r\n\r\nAncillae verterem eleifend his at? Nam vidit iusto petentium at, vis nusquam dissentias cu, etiam doctus adversarium eam no. At alterum definiebas efficiantur eos, pro labitur vituperatoribus ne, eu odio legere vim. Ad nec verear appellantur? Ad qui vulputate persequeris.",
     "user_id": 2
   },
   {
     "title": "Best Programmers Throughout History",
     "content": "Mel nulla legimus senserit id. Vim purto tractatos in, te vix error regione, erant laudem legere an vel. Falli fierent ius ex! In legere iriure est, id vis prima maluisset, purto numquam inimicus ut eos! In duo antiopam salutatus, an vel quodsi virtute definitiones.\r\n\r\nEst te sumo voluptaria, ius no putant argumentum, alienum ocurreret vim cu? Volumus democritum no vel, virtute commune an est. Vel te propriae lobortis rationibus, no eum odio neglegentur? Duo an sumo ignota latine! Nec mazim aperiam percipitur eu, id his dicit omnium.",
     "user_id": 2
   },
   {
     "title": "How To Create A YouTube Channel",
     "content": "Sit et novum omnes. Nec ea quas minim tractatos, usu in aperiam mentitum necessitatibus, ut omnis equidem moderatius quo. Eos ad putent aeterno praesent. Eos omnium similique id, his accommodare philosophia at. Causae lucilius similique in mea, ut regione tritani voluptatibus mel! At possim offendit eum, aeque denique prodesset pro te?\r\n\r\nAt pro quem laudem. Et agam democritum eos? Ea quod probatus usu, no ferri fabulas cotidieque mei? Numquam nusquam quo in, quo et molestiae complectitur. Nihil semper ei qui.\r\n\r\nModo omnes forensibus duo ex, te est diceret bonorum labores! Magna ponderum eos ea. Cu vim diceret mnesarchum, graeci periculis in vis. Est no iriure suavitate!",
     "user_id": 2
   },
   {
     "title": "How I Record My Videos",
     "content": "Ad vel possim delicatissimi, delectus detraxit per cu. Ad pri vidit modus altera! In erat complectitur sit, quo no nostro insolens? Aliquam patrioque scribentur quo ad, partem commune eos at. Eius vivendo comprehensam has ne, sea ne eros mazim oratio. Soluta populo te duo, ne pro causae fabulas percipitur, feugiat.",
     "user_id": 1
   },
   {
     "title": "Python and Physics",
     "content": "Agam mediocritatem sed ex, fabellas recusabo dissentias vix te. No principes consequat inciderint pri, ea mundi affert persecuti mea, ne usu veri regione nostrum! An tibique dissentiet referrentur pro, ridens temporibus eu est! Ius ne omnes affert rationibus, ut detraxit qualisque usu. Accusamus reformidans sea id?\r\n\r\nEu aliquip gloriatur mei. Qui ad sint scripserit? Te instructior definitiones mel, sale mutat everti at his. Ea mea quot recusabo philosophia. Et nam quod adipisci, quo atqui appetere recusabo id, detraxit inimicus vim.",
     "user_id": 1
   },
   {
     "title": "Just A Few More Healines Should Do It",
     "content": "Duo at tibique commune vulputate, ex facilis tacimates disputationi mei. Mel eu inani prompta labores! Audire omnesque offendit ex eos. An ferri accusata his, vel agam habeo maiestatis ex, eam mutat iisque concludaturque ut. Ut tamquam minimum partiendo vim. An nam vidit doming graecis.\r\n\r\nSingulis abhorreant his in, et altera audiam feugiat mei. Pri eius dolor persequeris id! Nam ea dolorem expetendis, idque everti suscipit qui te, noster repudiare dignissim per ex? No vim iriure tibique comprehensam, per utamur consequat.",
     "user_id": 1
   },
   {
     "title": "Music To Listen To While Coding",
     "content": "Feugait reprimique eu mel, te eum dico electram. Nam no nemore cotidieque. Vim cu suas atqui dicunt. Id labitur dissentiunt per, ignota maiorum pri no? Clita altera sanctus ex his!\r\n\r\nAt alia electram reprehendunt eam, sea te volumus quaestio. Commodo voluptua senserit ius ne, eu enim disputationi eam? Id pri omnium blandit, nullam denique nec no? Sapientem vituperata sit et, nisl facilisis periculis in est. Elaboraret accommodare id vel? Cibo eripuit ut has, sed cu liber invidunt.\r\n\r\nEi pro vide quas dolorum, sea no fugit sanctus neglegentur. Sit feugait disputationi ne. Id diceret periculis nec, sint nonumes in sea, cum.",
     "user_id": 1
   },
   {
     "title": "5 Tips for Writing Catchy Headlines",
     "content": "Ea homero possit epicuri est, debitis docendi tacimates cu duo? Ad lorem cetero disputando pri, veniam eruditi tacimates per te.",
     "user_id": 2
   },
   {
     "title": "The Rise of Data Science",
     "content": "Per omittam placerat at. Eius aeque ei mei. Usu ex partiendo salutandi. Pro illud placerat molestiae ex, habeo vidisse voluptatum cu vel, efficiendi accommodare eum ea! Ne has case minimum facilisis, pertinax efficiendi eu vel!\r\n\r\nEt movet semper assueverit his. Mei at liber vitae. Vix et periculis definiebas, vero falli.",
     "user_id": 2
   },
   {
     "title": "Best Videos For Learning Python",
     "content": "Mei ei mazim dicunt feugait? Ludus mandamus ne est, per ne iusto facilisis moderatius! Has agam utamur ad! Ius reque aeterno cu, fabellas facilisi repudiare eu sit, te cibo convenire similique est. Ea cum viderer imperdiet liberavisse.\r\n\r\nPro minim iuvaret ad. No nam ornatus principes euripidis, at sale vituperatoribus eos, eros regione scripserit id mea. Has ne inermis nostrum, quo tantas melius dissentias at! Ut vim tibique omnesque. An mel modo ponderum, eum at probo appetere imperdiet? Natum quaeque intellegebat per ex. Cu viris clita sit?\r\n\r\nReque menandri dissentias sed ne, no tota nonumes eos, vix in tempor maiestatis erant.",
     "user_id": 1
   },
   {
     "title": "Top 10 Python Tips and Tricks",
     "content": "Pro minim iuvaret ad. No nam ornatus principes euripidis, at sale vituperatoribus eos, eros regione scripserit id mea. Has ne inermis nostrum, quo tantas melius dissentias at! Ut vim tibique omnesque. An mel modo ponderum, eum at probo appetere imperdiet? Natum quaeque intellegebat per ex. Cu viris clita sit?\r\n\r\nReque menandri dissentias sed ne, no tota nonumes eos, vix in tempor maiestatis erant.",
     "user_id": 1
   },
   {
     "title": "Top 5 YouTube Channels For Learning Programming",
     "content": "Quo inani quando ea, mel an vide adversarium suscipiantur. Et dicunt eleifend splendide pro. Nibh animal dolorem vim ex, nec te agam referrentur. Usu admodum ocurreret ne.\r\n\r\nEt dico audire cotidieque sed, cibo latine ut has, an case magna alienum.",
     "user_id": 2
   },
   {
     "title": "My Latest Updated Post",
     "content": "Erat expetenda definitionem id eos. Semper suscipit eum ut, eum ex nemore copiosae. Nam probatus pertinacia eu! No alii voluptua abhorreant nec, te pro impedit concludaturque, in sea malis torquatos disputationi! Nam te alii nobis ponderum, ei fugit accusamus pro.\r\n\r\nCongue salutandi ex eam! Mei an prima consulatu, erat detracto eu quo? Vim ea esse utinam efficiantur, at noster dicunt.",
     "user_id": 1
   }
 ]
 ```

* Email and Password Reset

** Setting up password-reset pages

Django has built-in many functions including security tokens that allow only the user with their token to be able to reset their password. This will be detailed further in the password-reset-confirm section.

In term of setting up the password-reset functionality,  we need four different views *and* email integration. The pages are:
1. *password_reset*: Form where user submits their email address to request password reset instruction.
2. *password_reset_done*: The page that is displayed to user after they have submitted the password reset request, usually just displaying simple instruction telling user to go check their email
3. *password_reset_confirm*: The link that is emailed to the user. This is view will validate the token that has been provided in the URL and display the password reset form if the token is valid.
4. *password_reset_complete*: Page that is displayed after user has successfully changed their password.


First of all we are going into `django_project\urls.py`, where we have our admin route, register route, login route to create a new route for our password reset view.  Similar to the LoginView and LogoutView, the password reset view will also be built-in to the auth view that we have already imported.

First, we'll create a url pattern for our new view 'password-reset' in *urls.py*:
``` python
"""django_project URL Configuration

The `urlpatterns` list routes URLs to views. For more information please see:
    https://docs.djangoproject.com/en/2.2/topics/http/urls/
Examples:
Function views
    1. Add an import:  from my_app import views
    2. Add a URL to urlpatterns:  path('', views.home, name='home')
Class-based views
    1. Add an import:  from other_app.views import Home
    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
Including another URLconf
    1. Import the include() function: from django.urls import include, path
    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
"""
from django.contrib import admin
from django.urls import path, include
from users import views as user_views
from django.contrib.auth import views as auth_views
from django.conf import settings
from django.conf.urls.static import static


urlpatterns = [
    path('admin/', admin.site.urls),
    path('', include('blog.urls')),
    path('register/', user_views.register, name='register'),
    path('login/', auth_views.LoginView.as_view(template_name='users/login.html'), name='login'),
    path('logout/', auth_views.LogoutView.as_view(template_name='users/logout.html'), name='logout'),
    path('password-reset', 
         auth_views.PasswordResetView.as_view(template_name='users/password_reset.html'), 
         name='password_reset'),
    path('profile/', user_views.profile, name='profile')
]

if settings.DEBUG:
    urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)
```

Moving on, as we have specified our template to be *users/password_reset.html*, we will now need to create a new template in `users/templates/users/password_reset.html`.

For this template we are going to copy our Login template (login.html) as both of these require us to fill in our email address. We also need to change a few things i.e the legend and the button label..

```html
{% extends "blog/base.html" %}
{% load crispy_forms_tags %}

{% block content %}
    <div class="content-section">
        <form method="POST">
            <!-- The csrf token adds an extra layer of security. It's a must-have for Django. -->
            {% csrf_token %}
            <fieldset class="form-group">
                <legend class="border-bottm mb-4">Reset Password</legend>
                {{ form | crispy  }}
            </fieldset>
            <div class="form-group">
                <button class="btn btn-outline-info" type="submit">Request Password Reset</button>
            </div>
        </form>
    </div>
{% endblock content%}
```

Now that the form is there, we'll need to also handle the submit button i.e the POST message. This would just be a route that tells the user that the email has been sent and they need to check their inbox. For this we'll go back to `django_project/urls.py`:
```python
...
    path('password-reset/done',
         auth_views.PasswordResetDoneView.as_view
         (template_name='users/password_reset_done.html'),
         name='password_reset_done'
         ),  
....
```

.. Now we need to also create `users/templates/users/password_reset_done.html`. This is just an informative page and there isn't any fancy forms or anything so we can just copy the LogOut template and reuse most of that.

```html
{% extends "blog/base.html" %}

{% block content %}
    <div class="alert alert-info">
        An email has been sent with instructions to reset your password.
        Please check your inbox.
    </div>
{% endblock content%}
```

After this, if we save our project and try to submit the request for password reset with an email that has been registered on the system, we'd get an error message with `NoReverseMatch at /password-reset/`. This is thrown after we submit a POST request to password-reset by hitting the submit button. Essentially, what is hapepning is that Django is trying to route to password_reset_confirm which has not been configured in our project. We'll need to do it now.

Note that in the error message, the following part is important:

```
{{ protocol }}://{{ domain }}{% url 'password_reset_confirm' uidb64=uid token=token %}
```

The uidb64 is user id encoded in base 64. The token checks if the password is valid. These are two parameters that are required since the password_reset_confirm view should be *expecting* them. Later on when we configure the route for password_reset_confirm, we should be accepting these two parameters in the url.

To create the *password_reset_confirm* page, first we'll need to go back to our project *urls.py* module again and create the routing:

```python
...
    path('password-reset-confirm/<uidb64>/<token>/',
        auth_views.PasswordResetConfirmView.as_view(
            template_name='users/password_reset_confirm.html'),
        name='password_reset_confirm'
        ),     
...
```

Note that we have to accept the two aforementioned parameters in the url.

Then we'll create the *password_reset_confirm.html* template that we specified above. The form on this page is similar to our password-reset template.

```html
{% extends "blog/base.html" %} {% load crispy_forms_tags %} {% block content %}
<div class="content-section">
    <form method="POST">
        <!-- The csrf token adds an extra layer of security. It's a must-have for Django. -->
        {% csrf_token %}
        <fieldset class="form-group">
            <legend class="border-bottm mb-4">Reset Password</legend>
            {{ form | crispy }}
        </fieldset>
        <div class="form-group">
            <button class="btn btn-outline-info" type="submit">Reset Password</button>
        </div>
    </form>
</div>
{% endblock content%}
```

The last route that we need to create is *password-reset-done*.

First, the route in *urls.py*:

```python
    path('password-reset/', 
         auth_views.PasswordResetView.as_view(
             template_name='users/password_reset.html',
         ), 
         name='password_reset'),
    path('password-reset/done',
         auth_views.PasswordResetDoneView.as_view(
             template_name='users/password_reset_done.html'),
         name='password_reset_done'
         ),
    path('password-reset-confirm/<uidb64>/<token>/',
        auth_views.PasswordResetConfirmView.as_view(
            template_name='users/password_reset_confirm.html'),
        name='password_reset_confirm'
        ),
    path('password-reset-complete/', 
        auth_views.PasswordResetCompleteView.as_view(
            template_name='users/password_reset_complete.html',
        ), 
        name='password_reset_complete'),  
```

then the template *users/templates/users/password_reset_complete.html*:

This page is informative only so it should be very simple to our password-reset-done view.

```html
{% extends "blog/base.html" %} 
{% block content %}
<div class="alert alert-info">
    Your password has been set!
</div>
<a href="{% url 'login' %}">Sign In Here</a> 
{% endblock content%}
```

** Setting up Email Integration

We are going to be using Gmail. (There are ways to set this up so our server can be used to send email instead of Gmail)

In order to use our Gmail account to send email from our Django server, we need to log in to our account using App Password. There should be online instructions how to do this and it involves turning on 2FA for Gmail. Essentially the result of this operation should be a password string that can be used for our project. 

If we don't want to set up App Password & 2FA, we can also disable non-secure app login and use our main password. However that would probably not be ideal.

After setting up our account so that an App Password can be used, we can now use it to log into our email via Python application.

What we need to do is to open our project settings module and add the email integration bit.

```python
...
# Setting up Email Integration Back-end (smtp)
EMAIL_BACKEND ='django.core.mail.backends.smtp.EmailBackend'
EMAIL_HOST = 'smtp.gmail.com'
EMAIL_PORT = 587
EMAIL_USE_TLS = True 

EMAIL_HOST_USER = os.environ.get('PGmail')
EMAIL_HOST_PASSWORD = os.environ.get('DjangoGmailPwd')

```

Note: Although one can hardcode their email user credentials in the settings module, this would however be bad practice. This is so we can hide sensitive information from the code. For the setup above, I have configured two environment variable in my host system for the my email address and its password. This bit was added to *`/.bashrc*:

```sh
# Environment Variable for Gmail App Password for Django:
export DjangoGmailPwd="q....."

# Environment Variable for my personal email:
export PGmail="kk...."

```

** End Result

<img class="mx-auto w-1/2" src="{{site.baseurl}}/assets/img/orgNotesImages/password-reset.png">

<img class="mx-auto w-1/2" src="{{site.baseurl}}/assets/img/orgNotesImages/password-reset-done.png">

<img class="mx-auto w-1/2" src="{{site.baseurl}}/assets/img/orgNotesImages/password-reset-email.png">

<img class="mx-auto w-1/2" src="{{site.baseurl}}/assets/img/orgNotesImages/password-reset-confirm.png">

<img class="mx-auto w-1/2" src="{{site.baseurl}}/assets/img/orgNotesImages/password-reset-complete.png">

For the final touch-up, we just need to add the Password Reset URL to the log in page.

*login.html*
```
{% extends "blog/base.html" %} {% load crispy_forms_tags %} {% block content %}
<div class="content-section">
    <form method="POST">
        <!-- The csrf token adds an extra layer of security. It's a must-have for Django. -->
        {% csrf_token %}
        <fieldset class="form-group">
            <legend class="border-bottm mb-4">Log in</legend>
            {{ form | crispy }}
        </fieldset>
        <div class="form-group">
            <button class="btn btn-outline-dark" type="submit">Login</button>
        </div>
        <small class="text-muted ml-2">
                <a href="{% url 'password_reset'%}">Forgot Your Password?</a>
            </small>
    </form>
    <div class="border-top pt-3">
        <small class="text-muted">
                Need an account? <a class="ml-2" href="{% url 'register' %}">Register here.</a>
            </small>
    </div>
</div>
{% endblock content%}
```

<img class="mx-auto w-1/2" src="{{site.baseurl}}/assets/img/orgNotesImages/password-reset-login.png">

* Directory structure

This the directory structure of the virtual environment:

<img class="mx-auto w-1/2" src="{{site.baseurl}}/assets/img/orgNotesImages/dir-venv.png">

This is the directory structure of the Django project:

<img class="mx-auto w-1/2" src="{{site.baseurl}}/assets/img/orgNotesImages/dir-django.png">

* References

During my learning of this lesson, I also stopped and looked at external resources when I come acorss content that are worth 'digging into'. Here is the list:

| Name                     | Note                                                  |
|--------------------------+-------------------------------------------------------|
| [[https://web.archive.org/web/20140409085244/http://www.deploydjango.com/django_project_structure][Django Project Structure]] | Talks about the directory structure of Django Project |
|                          |                                                       |
|                          |                                                       |
